<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A parsed call frame instruction."><title>CallFrameInstruction in gimli::read - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-c233d2bd.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="gimli" data-themes="" data-resource-suffix="" data-rustdoc-version="1.88.0-nightly (6bc57c6bf 2025-04-22)" data-channel="nightly" data-search-js="search-f7877310.js" data-settings-js="settings-5514c975.js" ><script src="../../static.files/storage-4e99c027.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-7ef8a74a.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc enum"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../gimli/index.html">gimli</a><span class="version">0.31.1</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Call<wbr>Frame<wbr>Instruction</a></h2><h3><a href="#variants">Variants</a></h3><ul class="block variant"><li><a href="#variant.AdvanceLoc" title="AdvanceLoc">AdvanceLoc</a></li><li><a href="#variant.ArgsSize" title="ArgsSize">ArgsSize</a></li><li><a href="#variant.DefCfa" title="DefCfa">DefCfa</a></li><li><a href="#variant.DefCfaExpression" title="DefCfaExpression">DefCfaExpression</a></li><li><a href="#variant.DefCfaOffset" title="DefCfaOffset">DefCfaOffset</a></li><li><a href="#variant.DefCfaOffsetSf" title="DefCfaOffsetSf">DefCfaOffsetSf</a></li><li><a href="#variant.DefCfaRegister" title="DefCfaRegister">DefCfaRegister</a></li><li><a href="#variant.DefCfaSf" title="DefCfaSf">DefCfaSf</a></li><li><a href="#variant.Expression" title="Expression">Expression</a></li><li><a href="#variant.NegateRaState" title="NegateRaState">NegateRaState</a></li><li><a href="#variant.Nop" title="Nop">Nop</a></li><li><a href="#variant.Offset" title="Offset">Offset</a></li><li><a href="#variant.OffsetExtendedSf" title="OffsetExtendedSf">OffsetExtendedSf</a></li><li><a href="#variant.Register" title="Register">Register</a></li><li><a href="#variant.RememberState" title="RememberState">RememberState</a></li><li><a href="#variant.Restore" title="Restore">Restore</a></li><li><a href="#variant.RestoreState" title="RestoreState">RestoreState</a></li><li><a href="#variant.SameValue" title="SameValue">SameValue</a></li><li><a href="#variant.SetLoc" title="SetLoc">SetLoc</a></li><li><a href="#variant.Undefined" title="Undefined">Undefined</a></li><li><a href="#variant.ValExpression" title="ValExpression">ValExpression</a></li><li><a href="#variant.ValOffset" title="ValOffset">ValOffset</a></li><li><a href="#variant.ValOffsetSf" title="ValOffsetSf">ValOffsetSf</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-Clone-for-CallFrameInstruction%3CT%3E" title="Clone">Clone</a></li><li><a href="#impl-Debug-for-CallFrameInstruction%3CT%3E" title="Debug">Debug</a></li><li><a href="#impl-Eq-for-CallFrameInstruction%3CT%3E" title="Eq">Eq</a></li><li><a href="#impl-PartialEq-for-CallFrameInstruction%3CT%3E" title="PartialEq">PartialEq</a></li><li><a href="#impl-StructuralPartialEq-for-CallFrameInstruction%3CT%3E" title="StructuralPartialEq">StructuralPartialEq</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-Freeze-for-CallFrameInstruction%3CT%3E" title="Freeze">Freeze</a></li><li><a href="#impl-RefUnwindSafe-for-CallFrameInstruction%3CT%3E" title="RefUnwindSafe">RefUnwindSafe</a></li><li><a href="#impl-Send-for-CallFrameInstruction%3CT%3E" title="Send">Send</a></li><li><a href="#impl-Sync-for-CallFrameInstruction%3CT%3E" title="Sync">Sync</a></li><li><a href="#impl-Unpin-for-CallFrameInstruction%3CT%3E" title="Unpin">Unpin</a></li><li><a href="#impl-UnwindSafe-for-CallFrameInstruction%3CT%3E" title="UnwindSafe">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T" title="Any">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T" title="Borrow&#60;T&#62;">Borrow&#60;T&#62;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T" title="BorrowMut&#60;T&#62;">BorrowMut&#60;T&#62;</a></li><li><a href="#impl-CloneToUninit-for-T" title="CloneToUninit">CloneToUninit</a></li><li><a href="#impl-From%3CT%3E-for-T" title="From&#60;T&#62;">From&#60;T&#62;</a></li><li><a href="#impl-Into%3CU%3E-for-T" title="Into&#60;U&#62;">Into&#60;U&#62;</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T" title="TryFrom&#60;U&#62;">TryFrom&#60;U&#62;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T" title="TryInto&#60;U&#62;">TryInto&#60;U&#62;</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="index.html">In gimli::<wbr>read</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../index.html">gimli</a>::<wbr><a href="index.html">read</a></div><h1>Enum <span class="enum">CallFrameInstruction</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/gimli/read/cfi.rs.html#2962-3256">Source</a> </span></div><pre class="rust item-decl"><code><div class="code-attribute">#[non_exhaustive]</div>pub enum CallFrameInstruction&lt;T: <a class="trait" href="trait.ReaderOffset.html" title="trait gimli::read::ReaderOffset">ReaderOffset</a>&gt; {
<details class="toggle type-contents-toggle"><summary class="hideme"><span>Show 23 variants</span></summary>    SetLoc {
        address: u64,
    },
    AdvanceLoc {
        delta: u32,
    },
    DefCfa {
        register: <a class="struct" href="../struct.Register.html" title="struct gimli::Register">Register</a>,
        offset: u64,
    },
    DefCfaSf {
        register: <a class="struct" href="../struct.Register.html" title="struct gimli::Register">Register</a>,
        factored_offset: i64,
    },
    DefCfaRegister {
        register: <a class="struct" href="../struct.Register.html" title="struct gimli::Register">Register</a>,
    },
    DefCfaOffset {
        offset: u64,
    },
    DefCfaOffsetSf {
        factored_offset: i64,
    },
    DefCfaExpression {
        expression: <a class="struct" href="struct.UnwindExpression.html" title="struct gimli::read::UnwindExpression">UnwindExpression</a>&lt;T&gt;,
    },
    Undefined {
        register: <a class="struct" href="../struct.Register.html" title="struct gimli::Register">Register</a>,
    },
    SameValue {
        register: <a class="struct" href="../struct.Register.html" title="struct gimli::Register">Register</a>,
    },
    Offset {
        register: <a class="struct" href="../struct.Register.html" title="struct gimli::Register">Register</a>,
        factored_offset: u64,
    },
    OffsetExtendedSf {
        register: <a class="struct" href="../struct.Register.html" title="struct gimli::Register">Register</a>,
        factored_offset: i64,
    },
    ValOffset {
        register: <a class="struct" href="../struct.Register.html" title="struct gimli::Register">Register</a>,
        factored_offset: u64,
    },
    ValOffsetSf {
        register: <a class="struct" href="../struct.Register.html" title="struct gimli::Register">Register</a>,
        factored_offset: i64,
    },
    Register {
        dest_register: <a class="struct" href="../struct.Register.html" title="struct gimli::Register">Register</a>,
        src_register: <a class="struct" href="../struct.Register.html" title="struct gimli::Register">Register</a>,
    },
    Expression {
        register: <a class="struct" href="../struct.Register.html" title="struct gimli::Register">Register</a>,
        expression: <a class="struct" href="struct.UnwindExpression.html" title="struct gimli::read::UnwindExpression">UnwindExpression</a>&lt;T&gt;,
    },
    ValExpression {
        register: <a class="struct" href="../struct.Register.html" title="struct gimli::Register">Register</a>,
        expression: <a class="struct" href="struct.UnwindExpression.html" title="struct gimli::read::UnwindExpression">UnwindExpression</a>&lt;T&gt;,
    },
    Restore {
        register: <a class="struct" href="../struct.Register.html" title="struct gimli::Register">Register</a>,
    },
    RememberState,
    RestoreState,
    ArgsSize {
        size: u64,
    },
    NegateRaState,
    Nop,
</details>}</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A parsed call frame instruction.</p>
</div></details><h2 id="variants" class="variants section-header">Variants (Non-exhaustive)<a href="#variants" class="anchor">Â§</a></h2><details class="toggle non-exhaustive"><summary class="hideme"><span>This enum is marked as non-exhaustive</span></summary><div class="docblock">Non-exhaustive enums could have additional variants added in future. Therefore, when matching against variants of non-exhaustive enums, an extra wildcard arm must be added to account for any future variants.</div></details><div class="variants"><section id="variant.SetLoc" class="variant"><a href="#variant.SetLoc" class="anchor">Â§</a><h3 class="code-header">SetLoc</h3></section><div class="docblock"><blockquote>
<ol>
<li>DW_CFA_set_loc</li>
</ol>
<p>The DW_CFA_set_loc instruction takes a single operand that represents
a target address. The required action is to create a new table row
using the specified address as the location. All other values in the
new row are initially identical to the current row. The new location
value is always greater than the current one. If the segment_size
field of this FDEâ€™s CIE is non- zero, the initial location is preceded
by a segment selector of the given length.</p>
</blockquote>
</div><div class="sub-variant" id="variant.SetLoc.fields"><h4>Fields</h4><div class="sub-variant-field"><span id="variant.SetLoc.field.address" class="section-header"><a href="#variant.SetLoc.field.address" class="anchor field">Â§</a><code>address: u64</code></span><div class="docblock"><p>The target address.</p>
</div></div></div><section id="variant.AdvanceLoc" class="variant"><a href="#variant.AdvanceLoc" class="anchor">Â§</a><h3 class="code-header">AdvanceLoc</h3></section><div class="docblock"><p>The <code>AdvanceLoc</code> instruction is used for all of <code>DW_CFA_advance_loc</code> and
<code>DW_CFA_advance_loc{1,2,4}</code>.</p>
<blockquote>
<ol start="2">
<li>DW_CFA_advance_loc</li>
</ol>
<p>The DW_CFA_advance instruction takes a single operand (encoded with
the opcode) that represents a constant delta. The required action is
to create a new table row with a location value that is computed by
taking the current entryâ€™s location value and adding the value of
delta * code_alignment_factor. All other values in the new row are
initially identical to the current row.</p>
</blockquote>
</div><div class="sub-variant" id="variant.AdvanceLoc.fields"><h4>Fields</h4><div class="sub-variant-field"><span id="variant.AdvanceLoc.field.delta" class="section-header"><a href="#variant.AdvanceLoc.field.delta" class="anchor field">Â§</a><code>delta: u32</code></span><div class="docblock"><p>The delta to be added to the current address.</p>
</div></div></div><section id="variant.DefCfa" class="variant"><a href="#variant.DefCfa" class="anchor">Â§</a><h3 class="code-header">DefCfa</h3></section><div class="docblock"><blockquote>
<ol>
<li>DW_CFA_def_cfa</li>
</ol>
<p>The DW_CFA_def_cfa instruction takes two unsigned LEB128 operands
representing a register number and a (non-factored) offset. The
required action is to define the current CFA rule to use the provided
register and offset.</p>
</blockquote>
</div><div class="sub-variant" id="variant.DefCfa.fields"><h4>Fields</h4><div class="sub-variant-field"><span id="variant.DefCfa.field.register" class="section-header"><a href="#variant.DefCfa.field.register" class="anchor field">Â§</a><code>register: <a class="struct" href="../struct.Register.html" title="struct gimli::Register">Register</a></code></span><div class="docblock"><p>The target registerâ€™s number.</p>
</div></div><div class="sub-variant-field"><span id="variant.DefCfa.field.offset" class="section-header"><a href="#variant.DefCfa.field.offset" class="anchor field">Â§</a><code>offset: u64</code></span><div class="docblock"><p>The non-factored offset.</p>
</div></div></div><section id="variant.DefCfaSf" class="variant"><a href="#variant.DefCfaSf" class="anchor">Â§</a><h3 class="code-header">DefCfaSf</h3></section><div class="docblock"><blockquote>
<ol start="2">
<li>DW_CFA_def_cfa_sf</li>
</ol>
<p>The DW_CFA_def_cfa_sf instruction takes two operands: an unsigned
LEB128 value representing a register number and a signed LEB128
factored offset. This instruction is identical to DW_CFA_def_cfa
except that the second operand is signed and factored. The resulting
offset is factored_offset * data_alignment_factor.</p>
</blockquote>
</div><div class="sub-variant" id="variant.DefCfaSf.fields"><h4>Fields</h4><div class="sub-variant-field"><span id="variant.DefCfaSf.field.register" class="section-header"><a href="#variant.DefCfaSf.field.register" class="anchor field">Â§</a><code>register: <a class="struct" href="../struct.Register.html" title="struct gimli::Register">Register</a></code></span><div class="docblock"><p>The target registerâ€™s number.</p>
</div></div><div class="sub-variant-field"><span id="variant.DefCfaSf.field.factored_offset" class="section-header"><a href="#variant.DefCfaSf.field.factored_offset" class="anchor field">Â§</a><code>factored_offset: i64</code></span><div class="docblock"><p>The factored offset.</p>
</div></div></div><section id="variant.DefCfaRegister" class="variant"><a href="#variant.DefCfaRegister" class="anchor">Â§</a><h3 class="code-header">DefCfaRegister</h3></section><div class="docblock"><blockquote>
<ol start="3">
<li>DW_CFA_def_cfa_register</li>
</ol>
<p>The DW_CFA_def_cfa_register instruction takes a single unsigned LEB128
operand representing a register number. The required action is to
define the current CFA rule to use the provided register (but to keep
the old offset). This operation is valid only if the current CFA rule
is defined to use a register and offset.</p>
</blockquote>
</div><div class="sub-variant" id="variant.DefCfaRegister.fields"><h4>Fields</h4><div class="sub-variant-field"><span id="variant.DefCfaRegister.field.register" class="section-header"><a href="#variant.DefCfaRegister.field.register" class="anchor field">Â§</a><code>register: <a class="struct" href="../struct.Register.html" title="struct gimli::Register">Register</a></code></span><div class="docblock"><p>The target registerâ€™s number.</p>
</div></div></div><section id="variant.DefCfaOffset" class="variant"><a href="#variant.DefCfaOffset" class="anchor">Â§</a><h3 class="code-header">DefCfaOffset</h3></section><div class="docblock"><blockquote>
<ol start="4">
<li>DW_CFA_def_cfa_offset</li>
</ol>
<p>The DW_CFA_def_cfa_offset instruction takes a single unsigned LEB128
operand representing a (non-factored) offset. The required action is
to define the current CFA rule to use the provided offset (but to keep
the old register). This operation is valid only if the current CFA
rule is defined to use a register and offset.</p>
</blockquote>
</div><div class="sub-variant" id="variant.DefCfaOffset.fields"><h4>Fields</h4><div class="sub-variant-field"><span id="variant.DefCfaOffset.field.offset" class="section-header"><a href="#variant.DefCfaOffset.field.offset" class="anchor field">Â§</a><code>offset: u64</code></span><div class="docblock"><p>The non-factored offset.</p>
</div></div></div><section id="variant.DefCfaOffsetSf" class="variant"><a href="#variant.DefCfaOffsetSf" class="anchor">Â§</a><h3 class="code-header">DefCfaOffsetSf</h3></section><div class="docblock"><blockquote>
<ol start="5">
<li>DW_CFA_def_cfa_offset_sf</li>
</ol>
<p>The DW_CFA_def_cfa_offset_sf instruction takes a signed LEB128 operand
representing a factored offset. This instruction is identical to
DW_CFA_def_cfa_offset except that the operand is signed and
factored. The resulting offset is factored_offset *
data_alignment_factor. This operation is valid only if the current CFA
rule is defined to use a register and offset.</p>
</blockquote>
</div><div class="sub-variant" id="variant.DefCfaOffsetSf.fields"><h4>Fields</h4><div class="sub-variant-field"><span id="variant.DefCfaOffsetSf.field.factored_offset" class="section-header"><a href="#variant.DefCfaOffsetSf.field.factored_offset" class="anchor field">Â§</a><code>factored_offset: i64</code></span><div class="docblock"><p>The factored offset.</p>
</div></div></div><section id="variant.DefCfaExpression" class="variant"><a href="#variant.DefCfaExpression" class="anchor">Â§</a><h3 class="code-header">DefCfaExpression</h3></section><div class="docblock"><blockquote>
<ol start="6">
<li>DW_CFA_def_cfa_expression</li>
</ol>
<p>The DW_CFA_def_cfa_expression instruction takes a single operand
encoded as a DW_FORM_exprloc value representing a DWARF
expression. The required action is to establish that expression as the
means by which the current CFA is computed.</p>
</blockquote>
</div><div class="sub-variant" id="variant.DefCfaExpression.fields"><h4>Fields</h4><div class="sub-variant-field"><span id="variant.DefCfaExpression.field.expression" class="section-header"><a href="#variant.DefCfaExpression.field.expression" class="anchor field">Â§</a><code>expression: <a class="struct" href="struct.UnwindExpression.html" title="struct gimli::read::UnwindExpression">UnwindExpression</a>&lt;T&gt;</code></span><div class="docblock"><p>The location of the DWARF expression.</p>
</div></div></div><section id="variant.Undefined" class="variant"><a href="#variant.Undefined" class="anchor">Â§</a><h3 class="code-header">Undefined</h3></section><div class="docblock"><blockquote>
<ol>
<li>DW_CFA_undefined</li>
</ol>
<p>The DW_CFA_undefined instruction takes a single unsigned LEB128
operand that represents a register number. The required action is to
set the rule for the specified register to â€œundefined.â€</p>
</blockquote>
</div><div class="sub-variant" id="variant.Undefined.fields"><h4>Fields</h4><div class="sub-variant-field"><span id="variant.Undefined.field.register" class="section-header"><a href="#variant.Undefined.field.register" class="anchor field">Â§</a><code>register: <a class="struct" href="../struct.Register.html" title="struct gimli::Register">Register</a></code></span><div class="docblock"><p>The target registerâ€™s number.</p>
</div></div></div><section id="variant.SameValue" class="variant"><a href="#variant.SameValue" class="anchor">Â§</a><h3 class="code-header">SameValue</h3></section><div class="docblock"><blockquote>
<ol start="2">
<li>DW_CFA_same_value</li>
</ol>
<p>The DW_CFA_same_value instruction takes a single unsigned LEB128
operand that represents a register number. The required action is to
set the rule for the specified register to â€œsame value.â€</p>
</blockquote>
</div><div class="sub-variant" id="variant.SameValue.fields"><h4>Fields</h4><div class="sub-variant-field"><span id="variant.SameValue.field.register" class="section-header"><a href="#variant.SameValue.field.register" class="anchor field">Â§</a><code>register: <a class="struct" href="../struct.Register.html" title="struct gimli::Register">Register</a></code></span><div class="docblock"><p>The target registerâ€™s number.</p>
</div></div></div><section id="variant.Offset" class="variant"><a href="#variant.Offset" class="anchor">Â§</a><h3 class="code-header">Offset</h3></section><div class="docblock"><p>The <code>Offset</code> instruction represents both <code>DW_CFA_offset</code> and
<code>DW_CFA_offset_extended</code>.</p>
<blockquote>
<ol start="3">
<li>DW_CFA_offset</li>
</ol>
<p>The DW_CFA_offset instruction takes two operands: a register number
(encoded with the opcode) and an unsigned LEB128 constant representing
a factored offset. The required action is to change the rule for the
register indicated by the register number to be an offset(N) rule
where the value of N is factored offset * data_alignment_factor.</p>
</blockquote>
</div><div class="sub-variant" id="variant.Offset.fields"><h4>Fields</h4><div class="sub-variant-field"><span id="variant.Offset.field.register" class="section-header"><a href="#variant.Offset.field.register" class="anchor field">Â§</a><code>register: <a class="struct" href="../struct.Register.html" title="struct gimli::Register">Register</a></code></span><div class="docblock"><p>The target registerâ€™s number.</p>
</div></div><div class="sub-variant-field"><span id="variant.Offset.field.factored_offset" class="section-header"><a href="#variant.Offset.field.factored_offset" class="anchor field">Â§</a><code>factored_offset: u64</code></span><div class="docblock"><p>The factored offset.</p>
</div></div></div><section id="variant.OffsetExtendedSf" class="variant"><a href="#variant.OffsetExtendedSf" class="anchor">Â§</a><h3 class="code-header">OffsetExtendedSf</h3></section><div class="docblock"><blockquote>
<ol start="5">
<li>DW_CFA_offset_extended_sf</li>
</ol>
<p>The DW_CFA_offset_extended_sf instruction takes two operands: an
unsigned LEB128 value representing a register number and a signed
LEB128 factored offset. This instruction is identical to
DW_CFA_offset_extended except that the second operand is signed and
factored. The resulting offset is factored_offset *
data_alignment_factor.</p>
</blockquote>
</div><div class="sub-variant" id="variant.OffsetExtendedSf.fields"><h4>Fields</h4><div class="sub-variant-field"><span id="variant.OffsetExtendedSf.field.register" class="section-header"><a href="#variant.OffsetExtendedSf.field.register" class="anchor field">Â§</a><code>register: <a class="struct" href="../struct.Register.html" title="struct gimli::Register">Register</a></code></span><div class="docblock"><p>The target registerâ€™s number.</p>
</div></div><div class="sub-variant-field"><span id="variant.OffsetExtendedSf.field.factored_offset" class="section-header"><a href="#variant.OffsetExtendedSf.field.factored_offset" class="anchor field">Â§</a><code>factored_offset: i64</code></span><div class="docblock"><p>The factored offset.</p>
</div></div></div><section id="variant.ValOffset" class="variant"><a href="#variant.ValOffset" class="anchor">Â§</a><h3 class="code-header">ValOffset</h3></section><div class="docblock"><blockquote>
<ol start="6">
<li>DW_CFA_val_offset</li>
</ol>
<p>The DW_CFA_val_offset instruction takes two unsigned LEB128 operands
representing a register number and a factored offset. The required
action is to change the rule for the register indicated by the
register number to be a val_offset(N) rule where the value of N is
factored_offset * data_alignment_factor.</p>
</blockquote>
</div><div class="sub-variant" id="variant.ValOffset.fields"><h4>Fields</h4><div class="sub-variant-field"><span id="variant.ValOffset.field.register" class="section-header"><a href="#variant.ValOffset.field.register" class="anchor field">Â§</a><code>register: <a class="struct" href="../struct.Register.html" title="struct gimli::Register">Register</a></code></span><div class="docblock"><p>The target registerâ€™s number.</p>
</div></div><div class="sub-variant-field"><span id="variant.ValOffset.field.factored_offset" class="section-header"><a href="#variant.ValOffset.field.factored_offset" class="anchor field">Â§</a><code>factored_offset: u64</code></span><div class="docblock"><p>The factored offset.</p>
</div></div></div><section id="variant.ValOffsetSf" class="variant"><a href="#variant.ValOffsetSf" class="anchor">Â§</a><h3 class="code-header">ValOffsetSf</h3></section><div class="docblock"><blockquote>
<ol start="7">
<li>DW_CFA_val_offset_sf</li>
</ol>
<p>The DW_CFA_val_offset_sf instruction takes two operands: an unsigned
LEB128 value representing a register number and a signed LEB128
factored offset. This instruction is identical to DW_CFA_val_offset
except that the second operand is signed and factored. The resulting
offset is factored_offset * data_alignment_factor.</p>
</blockquote>
</div><div class="sub-variant" id="variant.ValOffsetSf.fields"><h4>Fields</h4><div class="sub-variant-field"><span id="variant.ValOffsetSf.field.register" class="section-header"><a href="#variant.ValOffsetSf.field.register" class="anchor field">Â§</a><code>register: <a class="struct" href="../struct.Register.html" title="struct gimli::Register">Register</a></code></span><div class="docblock"><p>The target registerâ€™s number.</p>
</div></div><div class="sub-variant-field"><span id="variant.ValOffsetSf.field.factored_offset" class="section-header"><a href="#variant.ValOffsetSf.field.factored_offset" class="anchor field">Â§</a><code>factored_offset: i64</code></span><div class="docblock"><p>The factored offset.</p>
</div></div></div><section id="variant.Register" class="variant"><a href="#variant.Register" class="anchor">Â§</a><h3 class="code-header">Register</h3></section><div class="docblock"><blockquote>
<ol start="8">
<li>DW_CFA_register</li>
</ol>
<p>The DW_CFA_register instruction takes two unsigned LEB128 operands
representing register numbers. The required action is to set the rule
for the first register to be register(R) where R is the second
register.</p>
</blockquote>
</div><div class="sub-variant" id="variant.Register.fields"><h4>Fields</h4><div class="sub-variant-field"><span id="variant.Register.field.dest_register" class="section-header"><a href="#variant.Register.field.dest_register" class="anchor field">Â§</a><code>dest_register: <a class="struct" href="../struct.Register.html" title="struct gimli::Register">Register</a></code></span><div class="docblock"><p>The number of the register whose rule is being changed.</p>
</div></div><div class="sub-variant-field"><span id="variant.Register.field.src_register" class="section-header"><a href="#variant.Register.field.src_register" class="anchor field">Â§</a><code>src_register: <a class="struct" href="../struct.Register.html" title="struct gimli::Register">Register</a></code></span><div class="docblock"><p>The number of the register where the other registerâ€™s value can be
found.</p>
</div></div></div><section id="variant.Expression" class="variant"><a href="#variant.Expression" class="anchor">Â§</a><h3 class="code-header">Expression</h3></section><div class="docblock"><blockquote>
<ol start="9">
<li>DW_CFA_expression</li>
</ol>
<p>The DW_CFA_expression instruction takes two operands: an unsigned
LEB128 value representing a register number, and a DW_FORM_block value
representing a DWARF expression. The required action is to change the
rule for the register indicated by the register number to be an
expression(E) rule where E is the DWARF expression. That is, the DWARF
expression computes the address. The value of the CFA is pushed on the
DWARF evaluation stack prior to execution of the DWARF expression.</p>
</blockquote>
</div><div class="sub-variant" id="variant.Expression.fields"><h4>Fields</h4><div class="sub-variant-field"><span id="variant.Expression.field.register" class="section-header"><a href="#variant.Expression.field.register" class="anchor field">Â§</a><code>register: <a class="struct" href="../struct.Register.html" title="struct gimli::Register">Register</a></code></span><div class="docblock"><p>The target registerâ€™s number.</p>
</div></div><div class="sub-variant-field"><span id="variant.Expression.field.expression" class="section-header"><a href="#variant.Expression.field.expression" class="anchor field">Â§</a><code>expression: <a class="struct" href="struct.UnwindExpression.html" title="struct gimli::read::UnwindExpression">UnwindExpression</a>&lt;T&gt;</code></span><div class="docblock"><p>The location of the DWARF expression.</p>
</div></div></div><section id="variant.ValExpression" class="variant"><a href="#variant.ValExpression" class="anchor">Â§</a><h3 class="code-header">ValExpression</h3></section><div class="docblock"><blockquote>
<ol start="10">
<li>DW_CFA_val_expression</li>
</ol>
<p>The DW_CFA_val_expression instruction takes two operands: an unsigned
LEB128 value representing a register number, and a DW_FORM_block value
representing a DWARF expression. The required action is to change the
rule for the register indicated by the register number to be a
val_expression(E) rule where E is the DWARF expression. That is, the
DWARF expression computes the value of the given register. The value
of the CFA is pushed on the DWARF evaluation stack prior to execution
of the DWARF expression.</p>
</blockquote>
</div><div class="sub-variant" id="variant.ValExpression.fields"><h4>Fields</h4><div class="sub-variant-field"><span id="variant.ValExpression.field.register" class="section-header"><a href="#variant.ValExpression.field.register" class="anchor field">Â§</a><code>register: <a class="struct" href="../struct.Register.html" title="struct gimli::Register">Register</a></code></span><div class="docblock"><p>The target registerâ€™s number.</p>
</div></div><div class="sub-variant-field"><span id="variant.ValExpression.field.expression" class="section-header"><a href="#variant.ValExpression.field.expression" class="anchor field">Â§</a><code>expression: <a class="struct" href="struct.UnwindExpression.html" title="struct gimli::read::UnwindExpression">UnwindExpression</a>&lt;T&gt;</code></span><div class="docblock"><p>The location of the DWARF expression.</p>
</div></div></div><section id="variant.Restore" class="variant"><a href="#variant.Restore" class="anchor">Â§</a><h3 class="code-header">Restore</h3></section><div class="docblock"><p>The <code>Restore</code> instruction represents both <code>DW_CFA_restore</code> and
<code>DW_CFA_restore_extended</code>.</p>
<blockquote>
<ol start="11">
<li>DW_CFA_restore</li>
</ol>
<p>The DW_CFA_restore instruction takes a single operand (encoded with
the opcode) that represents a register number. The required action is
to change the rule for the indicated register to the rule assigned it
by the initial_instructions in the CIE.</p>
</blockquote>
</div><div class="sub-variant" id="variant.Restore.fields"><h4>Fields</h4><div class="sub-variant-field"><span id="variant.Restore.field.register" class="section-header"><a href="#variant.Restore.field.register" class="anchor field">Â§</a><code>register: <a class="struct" href="../struct.Register.html" title="struct gimli::Register">Register</a></code></span><div class="docblock"><p>The register to be reset.</p>
</div></div></div><section id="variant.RememberState" class="variant"><a href="#variant.RememberState" class="anchor">Â§</a><h3 class="code-header">RememberState</h3></section><div class="docblock"><blockquote>
<ol>
<li>DW_CFA_remember_state</li>
</ol>
<p>The DW_CFA_remember_state instruction takes no operands. The required
action is to push the set of rules for every register onto an implicit
stack.</p>
</blockquote>
</div><section id="variant.RestoreState" class="variant"><a href="#variant.RestoreState" class="anchor">Â§</a><h3 class="code-header">RestoreState</h3></section><div class="docblock"><blockquote>
<ol start="2">
<li>DW_CFA_restore_state</li>
</ol>
<p>The DW_CFA_restore_state instruction takes no operands. The required
action is to pop the set of rules off the implicit stack and place
them in the current row.</p>
</blockquote>
</div><section id="variant.ArgsSize" class="variant"><a href="#variant.ArgsSize" class="anchor">Â§</a><h3 class="code-header">ArgsSize</h3></section><div class="docblock"><blockquote>
<p>DW_CFA_GNU_args_size</p>
<p>GNU Extension</p>
<p>The DW_CFA_GNU_args_size instruction takes an unsigned LEB128 operand
representing an argument size. This instruction specifies the total of
the size of the arguments which have been pushed onto the stack.</p>
</blockquote>
</div><div class="sub-variant" id="variant.ArgsSize.fields"><h4>Fields</h4><div class="sub-variant-field"><span id="variant.ArgsSize.field.size" class="section-header"><a href="#variant.ArgsSize.field.size" class="anchor field">Â§</a><code>size: u64</code></span><div class="docblock"><p>The size of the arguments which have been pushed onto the stack</p>
</div></div></div><section id="variant.NegateRaState" class="variant"><a href="#variant.NegateRaState" class="anchor">Â§</a><h3 class="code-header">NegateRaState</h3></section><div class="docblock"><blockquote>
<p>DW_CFA_AARCH64_negate_ra_state</p>
<p>AArch64 Extension</p>
<p>The DW_CFA_AARCH64_negate_ra_state operation negates bit 0 of the
RA_SIGN_STATE pseudo-register. It does not take any operands. The
DW_CFA_AARCH64_negate_ra_state must not be mixed with other DWARF Register
Rule Instructions on the RA_SIGN_STATE pseudo-register in one Common
Information Entry (CIE) and Frame Descriptor Entry (FDE) program sequence.</p>
</blockquote>
</div><section id="variant.Nop" class="variant"><a href="#variant.Nop" class="anchor">Â§</a><h3 class="code-header">Nop</h3></section><div class="docblock"><blockquote>
<ol>
<li>DW_CFA_nop</li>
</ol>
<p>The DW_CFA_nop instruction has no operands and no required actions. It
is used as padding to make a CIE or FDE an appropriate size.</p>
</blockquote>
</div></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">Â§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Clone-for-CallFrameInstruction%3CT%3E" class="impl"><a class="src rightside" href="../../src/gimli/read/cfi.rs.html#2960">Source</a><a href="#impl-Clone-for-CallFrameInstruction%3CT%3E" class="anchor">Â§</a><h3 class="code-header">impl&lt;T: Clone + <a class="trait" href="trait.ReaderOffset.html" title="trait gimli::read::ReaderOffset">ReaderOffset</a>&gt; Clone for <a class="enum" href="enum.CallFrameInstruction.html" title="enum gimli::read::CallFrameInstruction">CallFrameInstruction</a>&lt;T&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl"><a class="src rightside" href="../../src/gimli/read/cfi.rs.html#2960">Source</a><a href="#method.clone" class="anchor">Â§</a><h4 class="code-header">fn <a class="fn">clone</a>(&amp;self) -&gt; <a class="enum" href="enum.CallFrameInstruction.html" title="enum gimli::read::CallFrameInstruction">CallFrameInstruction</a>&lt;T&gt;</h4></section></summary><div class='docblock'>Returns a copy of the value. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl"><span class="since rightside" title="Stable since Rust version 1.0.0">1.0.0</span><a href="#method.clone_from" class="anchor">Â§</a><h4 class="code-header">fn <a class="fn">clone_from</a>(&amp;mut self, source: &amp;Self)</h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-CallFrameInstruction%3CT%3E" class="impl"><a class="src rightside" href="../../src/gimli/read/cfi.rs.html#2960">Source</a><a href="#impl-Debug-for-CallFrameInstruction%3CT%3E" class="anchor">Â§</a><h3 class="code-header">impl&lt;T: Debug + <a class="trait" href="trait.ReaderOffset.html" title="trait gimli::read::ReaderOffset">ReaderOffset</a>&gt; Debug for <a class="enum" href="enum.CallFrameInstruction.html" title="enum gimli::read::CallFrameInstruction">CallFrameInstruction</a>&lt;T&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a class="src rightside" href="../../src/gimli/read/cfi.rs.html#2960">Source</a><a href="#method.fmt" class="anchor">Â§</a><h4 class="code-header">fn <a class="fn">fmt</a>(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result</h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialEq-for-CallFrameInstruction%3CT%3E" class="impl"><a class="src rightside" href="../../src/gimli/read/cfi.rs.html#2960">Source</a><a href="#impl-PartialEq-for-CallFrameInstruction%3CT%3E" class="anchor">Â§</a><h3 class="code-header">impl&lt;T: PartialEq + <a class="trait" href="trait.ReaderOffset.html" title="trait gimli::read::ReaderOffset">ReaderOffset</a>&gt; PartialEq for <a class="enum" href="enum.CallFrameInstruction.html" title="enum gimli::read::CallFrameInstruction">CallFrameInstruction</a>&lt;T&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq" class="method trait-impl"><a class="src rightside" href="../../src/gimli/read/cfi.rs.html#2960">Source</a><a href="#method.eq" class="anchor">Â§</a><h4 class="code-header">fn <a class="fn">eq</a>(&amp;self, other: &amp;<a class="enum" href="enum.CallFrameInstruction.html" title="enum gimli::read::CallFrameInstruction">CallFrameInstruction</a>&lt;T&gt;) -&gt; bool</h4></section></summary><div class='docblock'>Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.ne" class="method trait-impl"><span class="since rightside" title="Stable since Rust version 1.0.0">1.0.0</span><a href="#method.ne" class="anchor">Â§</a><h4 class="code-header">fn <a class="fn">ne</a>(&amp;self, other: &amp;Rhs) -&gt; bool</h4></section></summary><div class='docblock'>Tests for <code>!=</code>. The default implementation is almost always sufficient,
and should not be overridden without very good reason.</div></details></div></details><section id="impl-Eq-for-CallFrameInstruction%3CT%3E" class="impl"><a class="src rightside" href="../../src/gimli/read/cfi.rs.html#2960">Source</a><a href="#impl-Eq-for-CallFrameInstruction%3CT%3E" class="anchor">Â§</a><h3 class="code-header">impl&lt;T: Eq + <a class="trait" href="trait.ReaderOffset.html" title="trait gimli::read::ReaderOffset">ReaderOffset</a>&gt; Eq for <a class="enum" href="enum.CallFrameInstruction.html" title="enum gimli::read::CallFrameInstruction">CallFrameInstruction</a>&lt;T&gt;</h3></section><section id="impl-StructuralPartialEq-for-CallFrameInstruction%3CT%3E" class="impl"><a class="src rightside" href="../../src/gimli/read/cfi.rs.html#2960">Source</a><a href="#impl-StructuralPartialEq-for-CallFrameInstruction%3CT%3E" class="anchor">Â§</a><h3 class="code-header">impl&lt;T: <a class="trait" href="trait.ReaderOffset.html" title="trait gimli::read::ReaderOffset">ReaderOffset</a>&gt; StructuralPartialEq for <a class="enum" href="enum.CallFrameInstruction.html" title="enum gimli::read::CallFrameInstruction">CallFrameInstruction</a>&lt;T&gt;</h3></section></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">Â§</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-CallFrameInstruction%3CT%3E" class="impl"><a href="#impl-Freeze-for-CallFrameInstruction%3CT%3E" class="anchor">Â§</a><h3 class="code-header">impl&lt;T&gt; Freeze for <a class="enum" href="enum.CallFrameInstruction.html" title="enum gimli::read::CallFrameInstruction">CallFrameInstruction</a>&lt;T&gt;<div class="where">where
    T: Freeze,</div></h3></section><section id="impl-RefUnwindSafe-for-CallFrameInstruction%3CT%3E" class="impl"><a href="#impl-RefUnwindSafe-for-CallFrameInstruction%3CT%3E" class="anchor">Â§</a><h3 class="code-header">impl&lt;T&gt; RefUnwindSafe for <a class="enum" href="enum.CallFrameInstruction.html" title="enum gimli::read::CallFrameInstruction">CallFrameInstruction</a>&lt;T&gt;<div class="where">where
    T: RefUnwindSafe,</div></h3></section><section id="impl-Send-for-CallFrameInstruction%3CT%3E" class="impl"><a href="#impl-Send-for-CallFrameInstruction%3CT%3E" class="anchor">Â§</a><h3 class="code-header">impl&lt;T&gt; Send for <a class="enum" href="enum.CallFrameInstruction.html" title="enum gimli::read::CallFrameInstruction">CallFrameInstruction</a>&lt;T&gt;<div class="where">where
    T: Send,</div></h3></section><section id="impl-Sync-for-CallFrameInstruction%3CT%3E" class="impl"><a href="#impl-Sync-for-CallFrameInstruction%3CT%3E" class="anchor">Â§</a><h3 class="code-header">impl&lt;T&gt; Sync for <a class="enum" href="enum.CallFrameInstruction.html" title="enum gimli::read::CallFrameInstruction">CallFrameInstruction</a>&lt;T&gt;<div class="where">where
    T: Sync,</div></h3></section><section id="impl-Unpin-for-CallFrameInstruction%3CT%3E" class="impl"><a href="#impl-Unpin-for-CallFrameInstruction%3CT%3E" class="anchor">Â§</a><h3 class="code-header">impl&lt;T&gt; Unpin for <a class="enum" href="enum.CallFrameInstruction.html" title="enum gimli::read::CallFrameInstruction">CallFrameInstruction</a>&lt;T&gt;<div class="where">where
    T: Unpin,</div></h3></section><section id="impl-UnwindSafe-for-CallFrameInstruction%3CT%3E" class="impl"><a href="#impl-UnwindSafe-for-CallFrameInstruction%3CT%3E" class="anchor">Â§</a><h3 class="code-header">impl&lt;T&gt; UnwindSafe for <a class="enum" href="enum.CallFrameInstruction.html" title="enum gimli::read::CallFrameInstruction">CallFrameInstruction</a>&lt;T&gt;<div class="where">where
    T: UnwindSafe,</div></h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">Â§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a href="#impl-Any-for-T" class="anchor">Â§</a><h3 class="code-header">impl&lt;T&gt; Any for T<div class="where">where
    T: 'static + ?Sized,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a href="#method.type_id" class="anchor">Â§</a><h4 class="code-header">fn <a class="fn">type_id</a>(&amp;self) -&gt; TypeId</h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">Â§</a><h3 class="code-header">impl&lt;T&gt; Borrow&lt;T&gt; for T<div class="where">where
    T: ?Sized,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a href="#method.borrow" class="anchor">Â§</a><h4 class="code-header">fn <a class="fn">borrow</a>(&amp;self) -&gt; &amp;T</h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">Â§</a><h3 class="code-header">impl&lt;T&gt; BorrowMut&lt;T&gt; for T<div class="where">where
    T: ?Sized,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a href="#method.borrow_mut" class="anchor">Â§</a><h4 class="code-header">fn <a class="fn">borrow_mut</a>(&amp;mut self) -&gt; &amp;mut T</h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-CloneToUninit-for-T" class="impl"><a href="#impl-CloneToUninit-for-T" class="anchor">Â§</a><h3 class="code-header">impl&lt;T&gt; CloneToUninit for T<div class="where">where
    T: Clone,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone_to_uninit" class="method trait-impl"><a href="#method.clone_to_uninit" class="anchor">Â§</a><h4 class="code-header">unsafe fn <a class="fn">clone_to_uninit</a>(&amp;self, dest: *mut u8)</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>clone_to_uninit</code>)</span></div></span><div class='docblock'>Performs copy-assignment from <code>self</code> to <code>dest</code>. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a href="#impl-From%3CT%3E-for-T" class="anchor">Â§</a><h3 class="code-header">impl&lt;T&gt; From&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a href="#method.from" class="anchor">Â§</a><h4 class="code-header">fn <a class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a href="#impl-Into%3CU%3E-for-T" class="anchor">Â§</a><h3 class="code-header">impl&lt;T, U&gt; Into&lt;U&gt; for T<div class="where">where
    U: From&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a href="#method.into" class="anchor">Â§</a><h4 class="code-header">fn <a class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code>[From]&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">Â§</a><h3 class="code-header">impl&lt;T, U&gt; TryFrom&lt;U&gt; for T<div class="where">where
    U: Into&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a href="#associatedtype.Error-1" class="anchor">Â§</a><h4 class="code-header">type <a class="associatedtype">Error</a> = Infallible</h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a href="#method.try_from" class="anchor">Â§</a><h4 class="code-header">fn <a class="fn">try_from</a>(value: U) -&gt; Result&lt;T, &lt;T as TryFrom&lt;U&gt;&gt;::Error&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">Â§</a><h3 class="code-header">impl&lt;T, U&gt; TryInto&lt;U&gt; for T<div class="where">where
    U: TryFrom&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a href="#associatedtype.Error" class="anchor">Â§</a><h4 class="code-header">type <a class="associatedtype">Error</a> = &lt;U as TryFrom&lt;T&gt;&gt;::Error</h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a href="#method.try_into" class="anchor">Â§</a><h4 class="code-header">fn <a class="fn">try_into</a>(self) -&gt; Result&lt;U, &lt;U as TryFrom&lt;T&gt;&gt;::Error&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div></section></div></main></body></html>