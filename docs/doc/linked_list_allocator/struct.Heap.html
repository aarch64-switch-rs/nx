<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A fixed size heap backed by a linked list of free memory blocks."><title>Heap in linked_list_allocator - Rust</title><script> if (window.location.protocol !== "file:") document.write(`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2">`)</script><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-e935ef01ae1c1829.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="linked_list_allocator" data-themes="" data-resource-suffix="" data-rustdoc-version="1.79.0-nightly (c9f8f3438 2024-03-27)" data-channel="nightly" data-search-js="search-42d8da7a6b9792c2.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../static.files/storage-4c98445ec4002617.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-12cf3b4f4f9dc36d.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-04d5337699b92874.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../linked_list_allocator/index.html">linked_list_allocator</a><span class="version">0.9.1</span></h2></div><h2 class="location"><a href="#">Heap</a></h2><div class="sidebar-elems"><section><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.allocate_first_fit">allocate_first_fit</a></li><li><a href="#method.bottom">bottom</a></li><li><a href="#method.deallocate">deallocate</a></li><li><a href="#method.empty">empty</a></li><li><a href="#method.extend">extend</a></li><li><a href="#method.free">free</a></li><li><a href="#method.from_slice">from_slice</a></li><li><a href="#method.init">init</a></li><li><a href="#method.init_from_slice">init_from_slice</a></li><li><a href="#method.new">new</a></li><li><a href="#method.size">size</a></li><li><a href="#method.top">top</a></li><li><a href="#method.used">used</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-UnwindSafe-for-Heap">!UnwindSafe</a></li><li><a href="#impl-Freeze-for-Heap">Freeze</a></li><li><a href="#impl-RefUnwindSafe-for-Heap">RefUnwindSafe</a></li><li><a href="#impl-Send-for-Heap">Send</a></li><li><a href="#impl-Sync-for-Heap">Sync</a></li><li><a href="#impl-Unpin-for-Heap">Unpin</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T">Borrow&lt;T&gt;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T">BorrowMut&lt;T&gt;</a></li><li><a href="#impl-From%3CT%3E-for-T">From&lt;T&gt;</a></li><li><a href="#impl-Into%3CU%3E-for-T">Into&lt;U&gt;</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T">TryFrom&lt;U&gt;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T">TryInto&lt;U&gt;</a></li></ul></section><h2><a href="index.html">In crate linked_list_allocator</a></h2></div></nav><div class="sidebar-resizer"></div>
    <main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><div id="sidebar-button" tabindex="-1"><a href="../linked_list_allocator/all.html" title="show sidebar"></a></div><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" tabindex="-1"><a href="../help.html" title="help">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Struct <a href="index.html">linked_list_allocator</a>::<wbr><a class="struct" href="#">Heap</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../src/linked_list_allocator/lib.rs.html#35-40">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub struct Heap { <span class="comment">/* private fields */</span> }</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A fixed size heap backed by a linked list of free memory blocks.</p>
</div></details><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Heap" class="impl"><a class="src rightside" href="../src/linked_list_allocator/lib.rs.html#42-195">source</a><a href="#impl-Heap" class="anchor">§</a><h3 class="code-header">impl <a class="struct" href="struct.Heap.html" title="struct linked_list_allocator::Heap">Heap</a></h3></section></summary><div class="impl-items"><section id="method.empty" class="method"><a class="src rightside" href="../src/linked_list_allocator/lib.rs.html#55-62">source</a><h4 class="code-header">pub const fn <a href="#method.empty" class="fn">empty</a>() -&gt; <a class="struct" href="struct.Heap.html" title="struct linked_list_allocator::Heap">Heap</a></h4></section><details class="toggle method-toggle" open><summary><section id="method.init" class="method"><a class="src rightside" href="../src/linked_list_allocator/lib.rs.html#70-75">source</a><h4 class="code-header">pub unsafe fn <a href="#method.init" class="fn">init</a>(&amp;mut self, heap_bottom: usize, heap_size: usize)</h4></section></summary><div class="docblock"><p>Initializes an empty heap</p>
<h5 id="unsafety"><a class="doc-anchor" href="#unsafety">§</a>Unsafety</h5>
<p>This function must be called at most once and must only be used on an
empty heap.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.init_from_slice" class="method"><a class="src rightside" href="../src/linked_list_allocator/lib.rs.html#91-101">source</a><h4 class="code-header">pub fn <a href="#method.init_from_slice" class="fn">init_from_slice</a>(&amp;mut self, mem: &amp;'static mut [MaybeUninit&lt;u8&gt;])</h4></section></summary><div class="docblock"><p>Initialize an empty heap with provided memory.</p>
<p>The caller is responsible for procuring a region of raw memory that may be utilized by the
allocator. This might be done via any method such as (unsafely) taking a region from the
program’s memory, from a mutable static, or by allocating and leaking such memory from
another allocator.</p>
<p>The latter method may be especially useful if the underlying allocator does not perform
deallocation (e.g. a simple bump allocator). Then the overlaid linked-list-allocator can
provide memory reclamation.</p>
<h5 id="panics"><a class="doc-anchor" href="#panics">§</a>Panics</h5>
<p>This method panics if the heap is already initialized.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.new" class="method"><a class="src rightside" href="../src/linked_list_allocator/lib.rs.html#107-118">source</a><h4 class="code-header">pub unsafe fn <a href="#method.new" class="fn">new</a>(heap_bottom: usize, heap_size: usize) -&gt; <a class="struct" href="struct.Heap.html" title="struct linked_list_allocator::Heap">Heap</a></h4></section></summary><div class="docblock"><p>Creates a new heap with the given <code>bottom</code> and <code>size</code>. The bottom address must be valid
and the memory in the <code>[heap_bottom, heap_bottom + heap_size)</code> range must not be used for
anything else. This function is unsafe because it can cause undefined behavior if the
given address is invalid.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_slice" class="method"><a class="src rightside" href="../src/linked_list_allocator/lib.rs.html#124-130">source</a><h4 class="code-header">pub fn <a href="#method.from_slice" class="fn">from_slice</a>(mem: &amp;'static mut [MaybeUninit&lt;u8&gt;]) -&gt; <a class="struct" href="struct.Heap.html" title="struct linked_list_allocator::Heap">Heap</a></h4></section></summary><div class="docblock"><p>Creates a new heap from a slice of raw memory.</p>
<p>This has the same effect as [<code>init_from_slice</code>] on an empty heap, but it is combined into a
single operation that can not panic.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.allocate_first_fit" class="method"><a class="src rightside" href="../src/linked_list_allocator/lib.rs.html#137-145">source</a><h4 class="code-header">pub fn <a href="#method.allocate_first_fit" class="fn">allocate_first_fit</a>(&amp;mut self, layout: Layout) -&gt; Result&lt;NonNull&lt;u8&gt;, ()&gt;</h4></section></summary><div class="docblock"><p>Allocates a chunk of the given size with the given alignment. Returns a pointer to the
beginning of that chunk if it was successful. Else it returns <code>None</code>.
This function scans the list of free memory blocks and uses the first block that is big
enough. The runtime is in O(n) where n is the number of free blocks, but it should be
reasonably fast for small allocations.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.deallocate" class="method"><a class="src rightside" href="../src/linked_list_allocator/lib.rs.html#154-156">source</a><h4 class="code-header">pub unsafe fn <a href="#method.deallocate" class="fn">deallocate</a>(&amp;mut self, ptr: NonNull&lt;u8&gt;, layout: Layout)</h4></section></summary><div class="docblock"><p>Frees the given allocation. <code>ptr</code> must be a pointer returned
by a call to the <code>allocate_first_fit</code> function with identical size and alignment. Undefined
behavior may occur for invalid arguments, thus this function is unsafe.</p>
<p>This function walks the list of free memory blocks and inserts the freed block at the
correct place. If the freed block is adjacent to another free block, the blocks are merged
again. This operation is in <code>O(n)</code> since the list needs to be sorted by address.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.bottom" class="method"><a class="src rightside" href="../src/linked_list_allocator/lib.rs.html#159-161">source</a><h4 class="code-header">pub fn <a href="#method.bottom" class="fn">bottom</a>(&amp;self) -&gt; usize</h4></section></summary><div class="docblock"><p>Returns the bottom address of the heap.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.size" class="method"><a class="src rightside" href="../src/linked_list_allocator/lib.rs.html#164-166">source</a><h4 class="code-header">pub fn <a href="#method.size" class="fn">size</a>(&amp;self) -&gt; usize</h4></section></summary><div class="docblock"><p>Returns the size of the heap.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.top" class="method"><a class="src rightside" href="../src/linked_list_allocator/lib.rs.html#169-171">source</a><h4 class="code-header">pub fn <a href="#method.top" class="fn">top</a>(&amp;self) -&gt; usize</h4></section></summary><div class="docblock"><p>Return the top address of the heap</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.used" class="method"><a class="src rightside" href="../src/linked_list_allocator/lib.rs.html#174-176">source</a><h4 class="code-header">pub fn <a href="#method.used" class="fn">used</a>(&amp;self) -&gt; usize</h4></section></summary><div class="docblock"><p>Returns the size of the used part of the heap</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.free" class="method"><a class="src rightside" href="../src/linked_list_allocator/lib.rs.html#179-181">source</a><h4 class="code-header">pub fn <a href="#method.free" class="fn">free</a>(&amp;self) -&gt; usize</h4></section></summary><div class="docblock"><p>Returns the size of the free part of the heap</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.extend" class="method"><a class="src rightside" href="../src/linked_list_allocator/lib.rs.html#188-194">source</a><h4 class="code-header">pub unsafe fn <a href="#method.extend" class="fn">extend</a>(&amp;mut self, by: usize)</h4></section></summary><div class="docblock"><p>Extends the size of the heap by creating a new hole at the end</p>
<h5 id="unsafety-1"><a class="doc-anchor" href="#unsafety-1">§</a>Unsafety</h5>
<p>The new extended area must be valid</p>
</div></details></div></details></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-Heap" class="impl"><a href="#impl-Freeze-for-Heap" class="anchor">§</a><h3 class="code-header">impl Freeze for <a class="struct" href="struct.Heap.html" title="struct linked_list_allocator::Heap">Heap</a></h3></section><section id="impl-RefUnwindSafe-for-Heap" class="impl"><a href="#impl-RefUnwindSafe-for-Heap" class="anchor">§</a><h3 class="code-header">impl RefUnwindSafe for <a class="struct" href="struct.Heap.html" title="struct linked_list_allocator::Heap">Heap</a></h3></section><section id="impl-Send-for-Heap" class="impl"><a href="#impl-Send-for-Heap" class="anchor">§</a><h3 class="code-header">impl Send for <a class="struct" href="struct.Heap.html" title="struct linked_list_allocator::Heap">Heap</a></h3></section><section id="impl-Sync-for-Heap" class="impl"><a href="#impl-Sync-for-Heap" class="anchor">§</a><h3 class="code-header">impl Sync for <a class="struct" href="struct.Heap.html" title="struct linked_list_allocator::Heap">Heap</a></h3></section><section id="impl-Unpin-for-Heap" class="impl"><a href="#impl-Unpin-for-Heap" class="anchor">§</a><h3 class="code-header">impl Unpin for <a class="struct" href="struct.Heap.html" title="struct linked_list_allocator::Heap">Heap</a></h3></section><section id="impl-UnwindSafe-for-Heap" class="impl"><a href="#impl-UnwindSafe-for-Heap" class="anchor">§</a><h3 class="code-header">impl !UnwindSafe for <a class="struct" href="struct.Heap.html" title="struct linked_list_allocator::Heap">Heap</a></h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; Any for T<div class="where">where
    T: 'static + ?Sized,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a class="fn">type_id</a>(&amp;self) -&gt; TypeId</h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; Borrow&lt;T&gt; for T<div class="where">where
    T: ?Sized,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a class="fn">borrow</a>(&amp;self) -&gt; &amp;T</h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; BorrowMut&lt;T&gt; for T<div class="where">where
    T: ?Sized,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a class="fn">borrow_mut</a>(&amp;mut self) -&gt; &amp;mut T</h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; From&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; Into&lt;U&gt; for T<div class="where">where
    U: From&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code>[From]&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; TryFrom&lt;U&gt; for T<div class="where">where
    U: Into&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a class="associatedtype">Error</a> = Infallible</h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a class="fn">try_from</a>(value: U) -&gt; Result&lt;T, &lt;T as TryFrom&lt;U&gt;&gt;::Error&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; TryInto&lt;U&gt; for T<div class="where">where
    U: TryFrom&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a class="associatedtype">Error</a> = &lt;U as TryFrom&lt;T&gt;&gt;::Error</h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a class="fn">try_into</a>(self) -&gt; Result&lt;U, &lt;U as TryFrom&lt;T&gt;&gt;::Error&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div></section></div></main></body></html>