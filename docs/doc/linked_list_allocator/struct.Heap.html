<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A fixed size heap backed by a linked list of free memory blocks."><title>Heap in linked_list_allocator - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-42caa33d.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="linked_list_allocator" data-themes="" data-resource-suffix="" data-rustdoc-version="1.85.0-nightly (a47555110 2024-11-22)" data-channel="nightly" data-search-js="search-92e6798f.js" data-settings-js="settings-0f613d39.js" ><script src="../static.files/storage-59e33391.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-5f194d8c.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../linked_list_allocator/index.html">linked_<wbr>list_<wbr>allocator</a><span class="version">0.10.5</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Heap</a></h2><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.allocate_first_fit" title="allocate_first_fit">allocate_first_fit</a></li><li><a href="#method.bottom" title="bottom">bottom</a></li><li><a href="#method.deallocate" title="deallocate">deallocate</a></li><li><a href="#method.empty" title="empty">empty</a></li><li><a href="#method.extend" title="extend">extend</a></li><li><a href="#method.free" title="free">free</a></li><li><a href="#method.from_slice" title="from_slice">from_slice</a></li><li><a href="#method.init" title="init">init</a></li><li><a href="#method.init_from_slice" title="init_from_slice">init_from_slice</a></li><li><a href="#method.new" title="new">new</a></li><li><a href="#method.size" title="size">size</a></li><li><a href="#method.top" title="top">top</a></li><li><a href="#method.used" title="used">used</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-Send-for-Heap" title="Send">Send</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-Sync-for-Heap" title="!Sync">!Sync</a></li><li><a href="#impl-Freeze-for-Heap" title="Freeze">Freeze</a></li><li><a href="#impl-RefUnwindSafe-for-Heap" title="RefUnwindSafe">RefUnwindSafe</a></li><li><a href="#impl-Unpin-for-Heap" title="Unpin">Unpin</a></li><li><a href="#impl-UnwindSafe-for-Heap" title="UnwindSafe">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T" title="Any">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T" title="Borrow&#60;T&#62;">Borrow&#60;T&#62;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T" title="BorrowMut&#60;T&#62;">BorrowMut&#60;T&#62;</a></li><li><a href="#impl-From%3CT%3E-for-T" title="From&#60;T&#62;">From&#60;T&#62;</a></li><li><a href="#impl-Into%3CU%3E-for-T" title="Into&#60;U&#62;">Into&#60;U&#62;</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T" title="TryFrom&#60;U&#62;">TryFrom&#60;U&#62;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T" title="TryInto&#60;U&#62;">TryInto&#60;U&#62;</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="index.html">In crate linked_<wbr>list_<wbr>allocator</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><span class="rustdoc-breadcrumbs"><a href="index.html">linked_list_allocator</a></span><h1>Struct <span class="struct">Heap</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/linked_list_allocator/lib.rs.html#34-37">Source</a> </span></div><pre class="rust item-decl"><code>pub struct Heap { <span class="comment">/* private fields */</span> }</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A fixed size heap backed by a linked list of free memory blocks.</p>
</div></details><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Heap" class="impl"><a class="src rightside" href="../src/linked_list_allocator/lib.rs.html#55-267">Source</a><a href="#impl-Heap" class="anchor">§</a><h3 class="code-header">impl <a class="struct" href="struct.Heap.html" title="struct linked_list_allocator::Heap">Heap</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.empty" class="method"><a class="src rightside" href="../src/linked_list_allocator/lib.rs.html#57-62">Source</a><h4 class="code-header">pub const fn <a href="#method.empty" class="fn">empty</a>() -&gt; <a class="struct" href="struct.Heap.html" title="struct linked_list_allocator::Heap">Heap</a></h4></section></summary><div class="docblock"><p>Creates an empty heap. All allocate calls will return <code>None</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.init" class="method"><a class="src rightside" href="../src/linked_list_allocator/lib.rs.html#90-93">Source</a><h4 class="code-header">pub unsafe fn <a href="#method.init" class="fn">init</a>(&amp;mut self, heap_bottom: *mut u8, heap_size: usize)</h4></section></summary><div class="docblock"><p>Initializes an empty heap</p>
<p>The <code>heap_bottom</code> pointer is automatically aligned, so the <a href="struct.Heap.html#method.bottom" title="method linked_list_allocator::Heap::bottom"><code>bottom()</code></a>
method might return a pointer that is larger than <code>heap_bottom</code> after construction.</p>
<p>The given <code>heap_size</code> must be large enough to store the required
metadata, otherwise this function will panic. Depending on the
alignment of the <code>hole_addr</code> pointer, the minimum size is between
<code>2 * size_of::&lt;usize&gt;</code> and <code>3 * size_of::&lt;usize&gt;</code>.</p>
<p>The usable size for allocations will be truncated to the nearest
alignment of <code>align_of::&lt;usize&gt;</code>. Any extra bytes left at the end
will be reclaimed once sufficient additional space is given to
<a href="struct.Heap.html#method.extend" title="method linked_list_allocator::Heap::extend"><code>extend</code></a>.</p>
<h5 id="safety"><a class="doc-anchor" href="#safety">§</a>Safety</h5>
<p>This function must be called at most once and must only be used on an
empty heap.</p>
<p>The bottom address must be valid and the memory in the
<code>[heap_bottom, heap_bottom + heap_size)</code> range must not be used for anything else.
This function is unsafe because it can cause undefined behavior if the given address
is invalid.</p>
<p>The provided memory range must be valid for the <code>'static</code> lifetime.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.init_from_slice" class="method"><a class="src rightside" href="../src/linked_list_allocator/lib.rs.html#118-131">Source</a><h4 class="code-header">pub fn <a href="#method.init_from_slice" class="fn">init_from_slice</a>(&amp;mut self, mem: &amp;'static mut [MaybeUninit&lt;u8&gt;])</h4></section></summary><div class="docblock"><p>Initialize an empty heap with provided memory.</p>
<p>The caller is responsible for procuring a region of raw memory that may be utilized by the
allocator. This might be done via any method such as (unsafely) taking a region from the
program’s memory, from a mutable static, or by allocating and leaking such memory from
another allocator.</p>
<p>The latter approach may be especially useful if the underlying allocator does not perform
deallocation (e.g. a simple bump allocator). Then the overlaid linked-list-allocator can
provide memory reclamation.</p>
<p>The usable size for allocations will be truncated to the nearest
alignment of <code>align_of::&lt;usize&gt;</code>. Any extra bytes left at the end
will be reclaimed once sufficient additional space is given to
<a href="struct.Heap.html#method.extend" title="method linked_list_allocator::Heap::extend"><code>extend</code></a>.</p>
<h5 id="panics"><a class="doc-anchor" href="#panics">§</a>Panics</h5>
<p>This method panics if the heap is already initialized.</p>
<p>It also panics when the length of the given <code>mem</code> slice is not large enough to
store the required metadata. Depending on the alignment of the slice, the minimum
size is between <code>2 * size_of::&lt;usize&gt;</code> and <code>3 * size_of::&lt;usize&gt;</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.new" class="method"><a class="src rightside" href="../src/linked_list_allocator/lib.rs.html#156-161">Source</a><h4 class="code-header">pub unsafe fn <a href="#method.new" class="fn">new</a>(heap_bottom: *mut u8, heap_size: usize) -&gt; <a class="struct" href="struct.Heap.html" title="struct linked_list_allocator::Heap">Heap</a></h4></section></summary><div class="docblock"><p>Creates a new heap with the given <code>bottom</code> and <code>size</code>.</p>
<p>The <code>heap_bottom</code> pointer is automatically aligned, so the <a href="struct.Heap.html#method.bottom" title="method linked_list_allocator::Heap::bottom"><code>bottom()</code></a>
method might return a pointer that is larger than <code>heap_bottom</code> after construction.</p>
<p>The given <code>heap_size</code> must be large enough to store the required
metadata, otherwise this function will panic. Depending on the
alignment of the <code>hole_addr</code> pointer, the minimum size is between
<code>2 * size_of::&lt;usize&gt;</code> and <code>3 * size_of::&lt;usize&gt;</code>.</p>
<p>The usable size for allocations will be truncated to the nearest
alignment of <code>align_of::&lt;usize&gt;</code>. Any extra bytes left at the end
will be reclaimed once sufficient additional space is given to
<a href="struct.Heap.html#method.extend" title="method linked_list_allocator::Heap::extend"><code>extend</code></a>.</p>
<h5 id="safety-1"><a class="doc-anchor" href="#safety-1">§</a>Safety</h5>
<p>The bottom address must be valid and the memory in the
<code>[heap_bottom, heap_bottom + heap_size)</code> range must not be used for anything else.
This function is unsafe because it can cause undefined behavior if the given address
is invalid.</p>
<p>The provided memory range must be valid for the <code>'static</code> lifetime.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_slice" class="method"><a class="src rightside" href="../src/linked_list_allocator/lib.rs.html#168-174">Source</a><h4 class="code-header">pub fn <a href="#method.from_slice" class="fn">from_slice</a>(mem: &amp;'static mut [MaybeUninit&lt;u8&gt;]) -&gt; <a class="struct" href="struct.Heap.html" title="struct linked_list_allocator::Heap">Heap</a></h4></section></summary><div class="docblock"><p>Creates a new heap from a slice of raw memory.</p>
<p>This is a convenience function that has the same effect as calling
[<code>init_from_slice</code>] on an empty heap. All the requirements of <code>init_from_slice</code>
apply to this function as well.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.allocate_first_fit" class="method"><a class="src rightside" href="../src/linked_list_allocator/lib.rs.html#185-193">Source</a><h4 class="code-header">pub fn <a href="#method.allocate_first_fit" class="fn">allocate_first_fit</a>(&amp;mut self, layout: Layout) -&gt; Result&lt;NonNull&lt;u8&gt;, ()&gt;</h4></section></summary><div class="docblock"><p>Allocates a chunk of the given size with the given alignment. Returns a pointer to the
beginning of that chunk if it was successful. Else it returns <code>None</code>.
This function scans the list of free memory blocks and uses the first block that is big
enough. The runtime is in O(n) where n is the number of free blocks, but it should be
reasonably fast for small allocations.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.deallocate" class="method"><a class="src rightside" href="../src/linked_list_allocator/lib.rs.html#206-208">Source</a><h4 class="code-header">pub unsafe fn <a href="#method.deallocate" class="fn">deallocate</a>(&amp;mut self, ptr: NonNull&lt;u8&gt;, layout: Layout)</h4></section></summary><div class="docblock"><p>Frees the given allocation. <code>ptr</code> must be a pointer returned
by a call to the <code>allocate_first_fit</code> function with identical size and alignment.</p>
<p>This function walks the list of free memory blocks and inserts the freed block at the
correct place. If the freed block is adjacent to another free block, the blocks are merged
again. This operation is in <code>O(n)</code> since the list needs to be sorted by address.</p>
<h5 id="safety-2"><a class="doc-anchor" href="#safety-2">§</a>Safety</h5>
<p><code>ptr</code> must be a pointer returned by a call to the [<code>allocate_first_fit</code>] function with
identical layout. Undefined behavior may occur for invalid arguments.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.bottom" class="method"><a class="src rightside" href="../src/linked_list_allocator/lib.rs.html#214-216">Source</a><h4 class="code-header">pub fn <a href="#method.bottom" class="fn">bottom</a>(&amp;self) -&gt; *mut u8</h4></section></summary><div class="docblock"><p>Returns the bottom address of the heap.</p>
<p>The bottom pointer is automatically aligned, so the returned pointer
might be larger than the bottom pointer used for initialization.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.size" class="method"><a class="src rightside" href="../src/linked_list_allocator/lib.rs.html#223-225">Source</a><h4 class="code-header">pub fn <a href="#method.size" class="fn">size</a>(&amp;self) -&gt; usize</h4></section></summary><div class="docblock"><p>Returns the size of the heap.</p>
<p>This is the size the heap is using for allocations, not necessarily the
total amount of bytes given to the heap. To determine the exact memory
boundaries, use <a href="struct.Heap.html#method.bottom" title="method linked_list_allocator::Heap::bottom"><code>bottom</code></a> and <a href="struct.Heap.html#method.top" title="method linked_list_allocator::Heap::top"><code>top</code></a>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.top" class="method"><a class="src rightside" href="../src/linked_list_allocator/lib.rs.html#232-234">Source</a><h4 class="code-header">pub fn <a href="#method.top" class="fn">top</a>(&amp;self) -&gt; *mut u8</h4></section></summary><div class="docblock"><p>Return the top address of the heap.</p>
<p>Note: The heap may choose to not use bytes at the end for allocations
until there is enough room for metadata, but it still retains ownership
over memory from <a href="struct.Heap.html#method.bottom" title="method linked_list_allocator::Heap::bottom"><code>bottom</code></a> to the address returned.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.used" class="method"><a class="src rightside" href="../src/linked_list_allocator/lib.rs.html#237-239">Source</a><h4 class="code-header">pub fn <a href="#method.used" class="fn">used</a>(&amp;self) -&gt; usize</h4></section></summary><div class="docblock"><p>Returns the size of the used part of the heap</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.free" class="method"><a class="src rightside" href="../src/linked_list_allocator/lib.rs.html#242-244">Source</a><h4 class="code-header">pub fn <a href="#method.free" class="fn">free</a>(&amp;self) -&gt; usize</h4></section></summary><div class="docblock"><p>Returns the size of the free part of the heap</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.extend" class="method"><a class="src rightside" href="../src/linked_list_allocator/lib.rs.html#264-266">Source</a><h4 class="code-header">pub unsafe fn <a href="#method.extend" class="fn">extend</a>(&amp;mut self, by: usize)</h4></section></summary><div class="docblock"><p>Extends the size of the heap by creating a new hole at the end.</p>
<p>Small extensions are not guaranteed to grow the usable size of
the heap. In order to grow the Heap most effectively, extend by
at least <code>2 * size_of::&lt;usize&gt;</code>, keeping the amount a multiple of
<code>size_of::&lt;usize&gt;</code>.</p>
<p>Calling this method on an uninitialized Heap will panic.</p>
<h5 id="safety-3"><a class="doc-anchor" href="#safety-3">§</a>Safety</h5>
<p>The amount of data given in <code>by</code> MUST exist directly after the original
range of data provided when constructing the <a href="struct.Heap.html" title="struct linked_list_allocator::Heap">Heap</a>. The additional data
must have the same lifetime of the original range of data.</p>
<p>Even if this operation doesn’t increase the <a href="struct.Heap.html#method.size" title="method linked_list_allocator::Heap::size">usable size</a>
by exactly <code>by</code> bytes, those bytes are still owned by the Heap for
later use.</p>
</div></details></div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><section id="impl-Send-for-Heap" class="impl"><a class="src rightside" href="../src/linked_list_allocator/lib.rs.html#53">Source</a><a href="#impl-Send-for-Heap" class="anchor">§</a><h3 class="code-header">impl Send for <a class="struct" href="struct.Heap.html" title="struct linked_list_allocator::Heap">Heap</a></h3></section></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-Heap" class="impl"><a href="#impl-Freeze-for-Heap" class="anchor">§</a><h3 class="code-header">impl Freeze for <a class="struct" href="struct.Heap.html" title="struct linked_list_allocator::Heap">Heap</a></h3></section><section id="impl-RefUnwindSafe-for-Heap" class="impl"><a href="#impl-RefUnwindSafe-for-Heap" class="anchor">§</a><h3 class="code-header">impl RefUnwindSafe for <a class="struct" href="struct.Heap.html" title="struct linked_list_allocator::Heap">Heap</a></h3></section><section id="impl-Sync-for-Heap" class="impl"><a href="#impl-Sync-for-Heap" class="anchor">§</a><h3 class="code-header">impl !Sync for <a class="struct" href="struct.Heap.html" title="struct linked_list_allocator::Heap">Heap</a></h3></section><section id="impl-Unpin-for-Heap" class="impl"><a href="#impl-Unpin-for-Heap" class="anchor">§</a><h3 class="code-header">impl Unpin for <a class="struct" href="struct.Heap.html" title="struct linked_list_allocator::Heap">Heap</a></h3></section><section id="impl-UnwindSafe-for-Heap" class="impl"><a href="#impl-UnwindSafe-for-Heap" class="anchor">§</a><h3 class="code-header">impl UnwindSafe for <a class="struct" href="struct.Heap.html" title="struct linked_list_allocator::Heap">Heap</a></h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; Any for T<div class="where">where
    T: 'static + ?Sized,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a class="fn">type_id</a>(&amp;self) -&gt; TypeId</h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; Borrow&lt;T&gt; for T<div class="where">where
    T: ?Sized,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a class="fn">borrow</a>(&amp;self) -&gt; &amp;T</h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; BorrowMut&lt;T&gt; for T<div class="where">where
    T: ?Sized,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a class="fn">borrow_mut</a>(&amp;mut self) -&gt; &amp;mut T</h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; From&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; Into&lt;U&gt; for T<div class="where">where
    U: From&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code>[From]&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; TryFrom&lt;U&gt; for T<div class="where">where
    U: Into&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a class="associatedtype">Error</a> = Infallible</h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a class="fn">try_from</a>(value: U) -&gt; Result&lt;T, &lt;T as TryFrom&lt;U&gt;&gt;::Error&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; TryInto&lt;U&gt; for T<div class="where">where
    U: TryFrom&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a class="associatedtype">Error</a> = &lt;U as TryFrom&lt;T&gt;&gt;::Error</h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a class="fn">try_into</a>(self) -&gt; Result&lt;U, &lt;U as TryFrom&lt;T&gt;&gt;::Error&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div></section></div></main></body></html>