searchState.loadedDescShard("gimli", 0, "<code>gimli</code> is a library for reading and writing the DWARF …\nARM 64-bit (AArch64) architecture specific definitions.\nAAarch64 extensions.\nARM architecture specific definitions.\nBig endian byte order.\nBig endian byte order.\nThe <code>.debug_abbrev</code> section.\nAn offset into the <code>.debug_abbrev</code> section.\nThe <code>.debug_addr</code> section.\nAn offset to a set of entries in the <code>.debug_addr</code> section.\nAn index into a set of addresses in the <code>.debug_addr</code> …\nThe <code>.debug_aranges</code> section.\nAn offset into the <code>.debug_aranges</code> section.\nThe <code>.debug_cu_index</code> section.\nThe <code>.debug_frame</code> section.\nAn offset into the <code>.debug_frame</code> section.\nThe <code>.debug_info</code> section.\nAn offset into the <code>.debug_info</code> section.\nAn offset into the <code>.debug_info</code> section.\nThe <code>.debug_line</code> section.\nAn offset into the <code>.debug_line</code> section.\nThe <code>.debug_line_str</code> section.\nAn offset into the <code>.debug_line_str</code> section.\nThe <code>.debug_loc</code> section.\nThe <code>.debug_loclists</code> section.\nAn offset to a set of location list offsets in the …\nAn index into a set of location list offsets in the …\nThe <code>.debug_macinfo</code> section.\nAn offset into the <code>.debug_macinfo</code> section.\nThe <code>.debug_macro</code> section.\nAn offset into the <code>.debug_macro</code> section.\nThe <code>.debug_pubnames</code> section.\nThe <code>.debug_pubtypes</code> section.\nThe <code>.debug_ranges</code> section.\nThe <code>.debug_rnglists</code> section.\nAn offset to a set of range list offsets in the …\nAn index into a set of range list offsets in the …\nThe <code>.debug_str</code> section.\nAn offset into the <code>.debug_str</code> section.\nThe <code>.debug_str_offsets</code> section.\nAn offset to a set of entries in the <code>.debug_str_offsets</code> …\nAn index into a set of entries in the <code>.debug_str_offsets</code> …\nThe <code>.debug_tu_index</code> section.\nA type signature as used in the <code>.debug_types</code> section.\nThe <code>.debug_types</code> section.\nAn offset into the <code>.debug_types</code> section.\nAn offset into the <code>.debug_types</code> section.\nA default set of extensions, including some common GNU …\n32-bit DWARF\n64-bit DWARF\nThe “type” of file with DWARF debugging information. …\nA .dwo split DWARF file.\nAn optionally-provided implementation-defined compilation …\nThe <code>.eh_frame</code> section.\nThe <code>.eh_frame_hdr</code> section.\nAn offset into the <code>.eh_frame</code> section.\nEncoding parameters that are commonly used for multiple …\nA trait describing the endianity of some buffer.\nWhether the format of a compilation unit is 32- or 64-bit.\nEncoding parameters for a line number program.\nLittle endian byte order.\nLittle endian byte order.\nAn offset into either the <code>.debug_loc</code> section or the …\nLoongArch architecture specific definitions.\nMIPS architecture specific definitions.\nA normal executable or object file.\nThe native endianity for the target platform.\nPowerPC 64bit\nAn offset into either the <code>.debug_ranges</code> section or the …\nAn offset into either the <code>.debug_ranges</code> section or the …\nA DWARF register number.\nRISC-V architecture specific definitions.\nByte order that is selectable at runtime.\nAn identifier for a DWARF section.\nAn offset into the <code>.debug_info</code> or <code>.debug_types</code> sections.\nWhich vendor extensions to support.\nIntel i386 architecture specific definitions.\nAMD64 architecture specific definitions.\nThe size of an address.\nReturns the <code>DebugInfoOffset</code> inside, or <code>None</code> otherwise.\nReturns the <code>DebugTypesOffset</code> inside, or <code>None</code> otherwise.\nConstant definitions.\nReturns a <code>DebugLocListsBase</code> with the default value of …\nReturns a <code>DebugRngListsBase</code> with the default value of …\nReturns a <code>DebugStrOffsetsBase</code> with the default value of …\nThe initial value of the <code>is_stmt</code> register.\nReturns the ELF section name for this kind, when found in …\nWhether the DWARF format is 32- or 64-bit.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturn the serialized size of an initial length field for …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturn true for big endian byte order.\nReturn true for little endian byte order.\nReturn true for little endian byte order.\nReturns true if this is a mergeable string section.\nRead and write DWARF’s “Little Endian Base 128” …\nThe minimum value which a special opcode can add to the …\nThe range of values which a special opcode can add to the …\nThe maximum number of individual operations that may be …\nThe size in bytes of the smallest target machine …\nReturns the ELF section name for this kind.\nConverts a register name into a register number.\nConverts a register name into a register number.\nConverts a register name into a register number.\nConverts a register name into a register number.\nConverts a register name into a register number.\nConverts a register name into a register number.\nConverts a register name into a register number.\nConverts a register name into a register number.\nRead DWARF debugging information.\nReads a 32 bit floating point number from <code>buf</code>.\nReads a 32 bit floating point number from <code>buf</code>.\nReads a 32 bit floating point number from <code>buf</code>.\nReads a 32 bit floating point number from <code>buf</code>.\nReads a signed 16 bit integer from <code>buf</code>.\nReads a signed 16 bit integer from <code>buf</code>.\nReads a signed 32 bit integer from <code>buf</code>.\nReads a signed 32 bit integer from <code>buf</code>.\nReads a signed 64 bit integer from <code>buf</code>.\nReads a signed 64 bit integer from <code>buf</code>.\nReads an unsigned 16 bit integer from <code>buf</code>.\nReads an unsigned 16 bit integer from <code>buf</code>.\nReads an unsigned 32 bit integer from <code>buf</code>.\nReads an unsigned 32 bit integer from <code>buf</code>.\nReads an unsigned 64 bit integer from <code>buf</code>.\nReads an unsigned 64 bit integer from <code>buf</code>.\nRead an unsigned n-bytes integer u64.\nRead an unsigned n-bytes integer u64.\nThe name of a register, or <code>None</code> if the register number is …\nThe name of a register, or <code>None</code> if the register number is …\nThe name of a register, or <code>None</code> if the register number is …\nThe name of a register, or <code>None</code> if the register number is …\nThe name of a register, or <code>None</code> if the register number is …\nThe name of a register, or <code>None</code> if the register number is …\nThe name of a register, or <code>None</code> if the register number is …\nThe name of a register, or <code>None</code> if the register number is …\nThe DWARF version of the header.\nReturn the natural word size for the format\nWrites an unsigned 16 bit integer <code>n</code> to <code>buf</code>.\nWrites an unsigned 16 bit integer <code>n</code> to <code>buf</code>.\nWrites an unsigned 32 bit integer <code>n</code> to <code>buf</code>.\nWrites an unsigned 32 bit integer <code>n</code> to <code>buf</code>.\nWrites an unsigned 64 bit integer <code>n</code> to <code>buf</code>.\nWrites an unsigned 64 bit integer <code>n</code> to <code>buf</code>.\nReturns the XCOFF section name for this kind.\nThe encodings of the constants used in the …\nThe encodings of the constants used in the …\nThe attribute encodings for DIE attributes.\nThe encodings of the constants used in the <code>DW_AT_encoding</code> …\nThe encodings of the constants used in the …\nThe opcode for a call frame instruction.\nThe child determination encodings for DIE attributes.\nThe encodings of the constants used in the <code>DW_AT_defaulted</code> …\nThe encodings of the constants used in the …\nThe encodings of the constants used in the <code>DW_AT_discr_list</code>…\nPointer encoding used by <code>.eh_frame</code>.\nThe encodings of the constants used in the <code>DW_AT_endianity</code> …\nThe attribute form encodings for DIE attributes.\nThe encodings of the constants used in the …\nName index attribute encodings.\nThe encodings of the constants used in the <code>DW_AT_inline</code> …\nThe encodings of the constants used in the <code>DW_AT_language</code> …\nThe encodings of the constants used in location list …\nThe encodings for the line number header entry formats.\nThe encodings for the extended opcodes for line number …\nThe encodings for the standard opcodes for line number …\nThe encodings for macro information entry types.\nThe encodings for DWARF expression operations.\nThe encodings of the constants used in the <code>DW_AT_ordering</code> …\nRange list entry encoding values.\nThe section type field in a <code>.dwp</code> unit index.\nThe section type field in a <code>.dwp</code> unit index with version 2.\nThe tag encodings for DIE attributes.\nThe unit type field in a unit header.\nThe encodings of the constants used in the <code>DW_AT_virtuality</code>…\nThe encodings of the constants used in the <code>DW_AT_visibility</code>…\nGet the pointer encoding’s application.\nGet the default DW_AT_lower_bound for this language.\nGet the pointer encoding’s format.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIs this encoding the absent pointer encoding?\nIs this coding indirect? If so, its encoded value is the …\nIs this a known, valid pointer encoding?\nA module for reading signed and unsigned integers that …\nRead a signed LEB128 number from the given <code>Reader</code> and …\nRead bytes until the LEB128 continuation bit is not set.\nRead an LEB128 u16 from the given <code>Reader</code> and return it or …\nRead an unsigned LEB128 number from the given <code>Reader</code> and …\nAn abbreviation declared that its tag is zero, but zero is …\nTake the absolute value of the top of the stack.\nRelocate the address if needed, and push it on the stack.\nThe piece is found in memory.\nRead the address at the given index in `.debug_addr, …\nA location from DWARF version &lt;= 4.\nA range from DWARF version &lt;= 4.\nAn address calculation overflowed.\nThe <code>AdvanceLoc</code> instruction is used for all of …\nBitwise <code>and</code> of the top two values on the stack.\nA single parsed arange.\nAn iterator over the aranges from a <code>.debug_aranges</code> section.\nA header for a set of entries in the <code>.debug_arange</code> section.\nAn iterator over the headers of a <code>.debug_aranges</code> section.\n“The rule is defined externally to this specification by …\nDW_CFA_GNU_args_size\nMarker trait for types that can be used as backing storage …\nAn attribute specification declared that its form is zero, …\nWe support the z-style augmentation defined by <code>.eh_frame</code>.\nInvalid branch target for a DW_OP_bra or DW_OP_skip.\nThe abbreviation’s has-children byte was not one of …\nThe specified length is impossible.\nAn error parsing a signed LEB128 value.\nAn error parsing an unsigned LEB128 value.\nFound an invalid UTF-8 string.\nDW_LLE_base_address\nDW_RLE_base_address\nOptional base addresses for the relative <code>DW_EH_PE_*</code> …\nDW_LLE_base_addressx\nDW_RLE_base_addressx\nBranch to the target location if the top of stack is …\nThe piece is represented by some constant bytes.\nEvaluate a DWARF expression as a subroutine.  The …\nCompute the call frame CFA and push it on the stack.\nA parsed call frame instruction.\nA lazy iterator parsing call frame instructions.\nCannot parse a pointer with a <code>DW_EH_PE_omit</code> encoding.\nThe canonical frame address (CFA) recovery rules.\nAn iterator over CIE and FDE entries in a <code>.debug_frame</code> or …\nEncountered a call frame instruction in a context in which …\nThis CFI entry is a <code>CommonInformationEntry</code>.\nEither a <code>CommonInformationEntry</code> (CIE) or a …\nA Common Information Entry holds information that is …\nThe <code>Evaluation</code> is complete, and <code>Evaluation::result()</code> can …\nThis is a pseudo-register with a constant value.\nRead the address at the given index in `.debug_addr, and …\nPop the top stack entry, convert it to a different type, …\nFound a data relative pointer, but the data base is …\nThe <code>.debug_abbrev.dwo</code> section.\nThe raw contents of the <code>.debug_addr</code> section.\nThe <code>DebugAranges</code> struct represents the DWARF address range …\nThe data in the <code>.debug_cu_index</code> section of a <code>.dwp</code> file.\n<code>DebugFrame</code> contains the <code>.debug_frame</code> section’s frame …\nThe <code>.debug_info.dwo</code> section.\nA section-relative reference.\nThe <code>.debug_line.dwo</code> section.\nThe <code>DebugLineStr</code> struct represents the DWARF strings found …\nThe raw contents of the <code>.debug_loc</code> section.\nThe <code>.debug_loc.dwo</code> section.\nThe <code>DebugLocLists</code> struct represents the DWARF data found …\nThe <code>.debug_loclists.dwo</code> section.\nThe <code>.debug_macinfo.dwo</code> section.\nThe <code>.debug_macro.dwo</code> section.\nThe raw contents of the <code>.debug_ranges</code> section.\nThe <code>DebugRngLists</code> struct represents the contents of the …\nThe <code>.debug_rnglists.dwo</code> section.\nThe <code>DebugStr</code> struct represents the DWARF strings found in …\nThe raw contents of the <code>.debug_str_offsets</code> section.\nThe <code>.debug_str_offsets.dwo</code> section.\nThe data in the <code>.debug_tu_index</code> section of a <code>.dwp</code> file.\nThe <code>.debug_types.dwo</code> section.\nDW_CFA_def_cfaThe DW_CFA_def_cfa instruction takes two …\nDW_CFA_def_cfa_expressionThe DW_CFA_def_cfa_expression …\nDW_CFA_def_cfa_offsetThe DW_CFA_def_cfa_offset instruction …\nDW_CFA_def_cfa_offset_sfThe DW_CFA_def_cfa_offset_sf …\nDW_CFA_def_cfa_registerThe DW_CFA_def_cfa_register …\nDW_CFA_def_cfa_sfThe DW_CFA_def_cfa_sf instruction takes …\nDW_LLE_default_location\nDereference the topmost value of the stack.\nA reference to a DIE, either relative to the current CU or …\nThis value is the decoded pointer value.\nDivide the top two values on the stack.\nDivision or modulus by zero when evaluating an expression.\nDrop an item from the stack.\nFound an abbreviation code that has already been used.\nFound a duplicate arange.\n<code>EhFrame</code> contains the frame unwinding information needed …\n<code>EhFrameHdr</code> contains the information about the <code>.eh_frame_hdr</code>…\nThe CFI binary search table that is an optional part of …\nAn iterator for <code>.eh_frame_hdr</code> section’s binary search …\nThe piece is empty.  Ordinarily this means the piece has …\nThe endianity of bytes that are read.\n<code>EndianBuf</code> has been renamed to <code>EndianSlice</code>. For ease of …\nA <code>&amp;[u8]</code> slice with endianity metadata.\nEvaluate an expression at the entry to the current …\nCompare the top two stack values for equality.\nContains the error value\nAn error that occurred when parsing.\nA DWARF expression evaluator.\nThe state of an <code>Evaluation</code> after evaluating a DWARF …\nSpecification of what storage should be used for <code>Evaluation</code>…\nExpected an attribute value to be a string form.\nExpected a zero, found something else.\nThe bytecode for a DWARF expression or location …\nThe CFA is obtained by evaluating a DWARF expression …\n“The previous value of this register is located at the …\nDW_CFA_expressionThe DW_CFA_expression instruction takes …\nThe storage used for the expression stack.\n32-bit floating point type.\nA 32-bit floating point value.\n64-bit floating point type.\nA 64-bit floating point value.\nThis CFI entry is a <code>FrameDescriptionEntry</code>, however fully …\nA <code>FrameDescriptionEntry</code> is a set of CFA instructions for …\nCompute the frame base (using <code>DW_AT_frame_base</code>), add the …\nFound a function relative pointer in a context that does …\nCompare the top two stack values using <code>&gt;=</code>.\nThe generic type, which is address-sized and of …\nA generic value, which is address-sized and of unspecified …\nCompare the top two stack values using <code>&gt;</code>.\nSigned 16-bit integer type.\nA signed 16-bit integer value.\nSigned 32-bit integer type.\nA signed 32-bit integer value.\nSigned 64-bit integer type.\nA signed 64-bit integer value.\nSigned 8-bit integer type.\nA signed 8-bit integer value.\nThe object is a pointer to a value which has no actual …\nThe piece is a pointer to a value which has no actual …\nThe object has no location, but has a known constant value.\nSection kinds which are permitted in a <code>.dwp</code> index.\nThis value is <em>not</em> the pointer value, but points to the …\nAn expression operation required an integral type but saw a\nThe end of an address range was before the beginning.\nThe size of a deref expression must not be larger than the …\nAn unrecognized operation was found while parsing a DWARF …\nAn expression-terminating operation was followed by …\n<code>DW_FORM_implicit_const</code> used in an invalid context.\nInvalid hash row in <code>.dwp</code> index.\nInvalid section count in <code>.dwp</code> index.\nInvalid slot count in <code>.dwp</code> index.\nThe expression had a piece followed by an expression …\nDW_OP_push_object_address used but no address passed in.\nThe shift value in an expression must be a non-negative …\nAn I/O error occurred while reading.\nType of the elements being stored.\nCompare the top two stack values using <code>&lt;=</code>.\nThe line range must not be zero.\nAn iterator over a location list.\nA single location of a piece of the result of a DWARF …\nA location list entry from the <code>.debug_loc</code> or …\nThe DWARF data found in <code>.debug_loc</code> and <code>.debug_loclists</code> …\nCompare the top two stack values using <code>&lt;</code>.\nThe maximum operations per instruction must not be zero.\nThe minimum instruction length must not be zero.\nSubtract the top two values on the stack.\nMissing DW_LNCT_path in file entry format.\nA compilation unit or type unit is missing its top level …\nModulus of the top two values on the stack.\nMultiply the top two values on the stack.\nCompare the top two stack values using <code>!=</code>.\nNegate the top of the stack.\nDW_CFA_AARCH64_negate_ra_state\nDid not find an entry at the given offset.\nDo not have unwind info for the given address.\nDW_CFA_nopThe DW_CFA_nop instruction has no operands and …\nNo operation.\nBitwise <code>not</code> of the top of the stack.\nExpected to find the CIE ID, but found something else.\nExpected to find a pointer to a CIE, but found the CIE ID …\nNot enough items on the stack when evaluating an …\nExpected to find a pointer to an FDE, but found a CIE …\n“The previous value of this register is saved at the …\nThe <code>Offset</code> instruction represents both <code>DW_CFA_offset</code> and …\nThe offset type associated with this CFI section. Either …\nThe type used for offsets and lengths.\nDW_CFA_offset_extended_sfThe DW_CFA_offset_extended_sf …\nThe given offset is out of bounds.\nDW_LLE_offset_pair\nDW_RLE_offset_pair\nContains the success value\nThe opcode base must not be zero.\nA single decoded DWARF expression operation.\nAn iterator for the operations in an expression.\nBitwise <code>or</code> of the top two values on the stack.\nThis represents a parameter that was optimized out.\n<code>ParsedEhFrameHdr</code> contains the parsed information from the …\nA partially parsed <code>FrameDescriptionEntry</code>.\nFound a PC relative pointer, but the section base is …\nPick an item from the stack and push it on top of the …\nThe description of a single piece of the result of a DWARF …\nTerminate a piece.\nAdd the top two values on the stack.\nAdd a constant to the topmost value on the stack.\nA decoded pointer.\nWhen evaluating call frame instructions, found a …\nPush the object address on the stack.\nAn address range from the <code>.debug_ranges</code>, <code>.debug_rnglists</code>, …\nThe DWARF data found in <code>.debug_ranges</code> and <code>.debug_rnglists</code> …\nA raw entry in .debug_loclists.\nA raw iterator over a location list.\nA raw entry in .debug_rnglists\nA raw iterator over an address range list.\nA trait for reading the data from a DWARF section.\nA trait for offsets with a DWARF section.\nAn identifier for an offset within a section reader.\n“The previous value of this register is stored in …\nDW_CFA_registerThe DW_CFA_register instruction takes two …\nIndicate that this piece’s location is in the given …\nThe piece is found in a register.\nThe CFA is given offset from the given register’s value.\nFind the value of the given register, add the offset, and …\nAn entry in the abstract CFI table that describes how to …\nAn unordered iterator for register rules.\nPop the top stack entry, reinterpret the bits in its value …\nTrait for relocating addresses and offsets while reading a …\nA <code>Reader</code> which applies relocations to addresses and …\nDW_CFA_remember_stateThe DW_CFA_remember_state instruction …\nThe <code>Evaluation</code> needs the DWARF expression at the given …\nThe <code>Evaluation</code> needs the <code>ValueType</code> for the base type DIE at\nThe <code>Evaluation</code> needs the CFA to proceed further.  Once the …\nThe <code>Evaluation</code> needs the value produced by evaluating a …\nThe <code>Evaluation</code> needs the frame base address to proceed …\nThe <code>Evaluation</code> needs an address from the <code>.debug_addr</code> …\nThe <code>Evaluation</code> needs a value from memory to proceed …\nThe <code>Evaluation</code> needs the value of the parameter at the …\nThe <code>Evaluation</code> needs a value from a register to proceed …\nThe <code>Evaluation</code> needs an address to be relocated to proceed …\nThe <code>Evaluation</code> needs a value from TLS to proceed further.  …\nThe <code>Restore</code> instruction represents both <code>DW_CFA_restore</code> and …\nDW_CFA_restore_stateThe DW_CFA_restore_state instruction …\nThe result of a parse.\nThe storage used for the results.\nAn iterator over an address range list.\nRotate the top three stack items.\nThe storage used for register rules in a unwind table row.\nThis register has not been modified from the previous …\nDW_CFA_same_valueThe DW_CFA_same_value instruction takes a …\nA convenience trait for loading DWARF sections from object …\nOptional base addresses for the relative <code>DW_EH_PE_*</code> …\nDW_CFA_set_locThe DW_CFA_set_loc instruction takes a …\nLogical left shift of the 2nd value on the stack by the …\nRight shift of the 2nd value on the stack by the number of …\nArithmetic left shift of the 2nd value on the stack by the …\nPush a signed constant value on the stack.  This handles …\nUnconditional branch to the target location.\nThe storage used for unwind table row stack.\nThe storage used for the evaluation stack.\nAttempted to push onto the CFI or evaluation stack, but it …\nThe object has no location, but its value is at the top of …\nDW_LLE_start_end\nDW_RLE_start_end\nDW_LLE_start_length\nDW_RLE_start_length\nDW_LLE_startx_endx\nDW_RLE_startx_endx\nDW_LLE_startx_length\nDW_RLE_startx_length\nIndicates that storage should be allocated on heap.\nSwap the top two stack items.\nCompute the address of a thread-local variable and push it …\nFound a <code>.text</code> relative pointer, but the <code>.text</code> base is …\nToo many iterations to compute the expression.\nThe CFI program defined more register rules than we have …\nAn expression operation used mismatching types.\nInterpret the value bytes as a constant of a given type, …\nUnsigned 16-bit integer type.\nAn unsigned 16-bit integer value.\nUnsigned 32-bit integer type.\nAn unsigned 32-bit integer value.\nUnsigned 64-bit integer type.\nAn unsigned 64-bit integer value.\nUnsigned 8-bit integer type.\nAn unsigned 8-bit integer value.\nA register that has this rule has no recoverable value in …\nDW_CFA_undefinedThe DW_CFA_undefined instruction takes a …\nHit the end of input before it was expected.\nRead a null entry before it was expected.\nThe partially parsed index from a <code>DebugCuIndex</code> or …\nInformation about a unit’s contribution to a section in …\nAn iterator over the section offsets and sizes for a row …\nAn offset into the current compilation or type unit.\nA CU-relative reference.\nFound a record with an unknown abbreviation code.\nFound an unknown CFI augmentation.\nAn unknown DW_CFA_* instruction.\nFound an unknown extended opcode.\nFound an unknown <code>DW_FORM_*</code> type.\nUnknown section type in <code>.dwp</code> index.\nUnknown section type in version 2 <code>.dwp</code> index.\nFound an unknown location-lists format.\nThe given pointer encoding is either unknown or invalid.\nFound an unknown range-lists format.\nFound an unknown reserved length value.\nFound an unknown standard opcode.\nFound an unknown DWARF version.\nPush an unsigned constant value on the stack.  This …\nRanges using AddressIndex are not supported yet.\nThe specified address size is not supported.\nA DIE attribute used an unsupported form.\nAn unsupported operation was found while evaluating a …\nThe specified field size is not supported.\nAn offset value was larger than the maximum supported …\nThe specified offset size is not supported.\nWe do not support the given pointer encoding yet.\nRegisters larger than <code>u16</code> are not supported.\nNonzero segment selector sizes aren’t supported yet.\nAn expression operation used types that are not supported.\nThe <code>DW_UT_*</code> value for this unit is not supported yet.\nCommon context needed when evaluating the call frame …\nSpecification of what storage should be used for …\nThe location of a DWARF expression within an unwind …\nAn offset into an <code>UnwindSection</code>.\nA section holding unwind information: either <code>.debug_frame</code> …\nThe <code>UnwindTable</code> iteratively evaluates a …\nA row in the virtual unwind table that describes how to …\n“The previous value of this register is the value …\nDW_CFA_val_expressionThe DW_CFA_val_expression instruction …\n“The previous value of this register is the value CFA+N …\nDW_CFA_val_offsetThe DW_CFA_val_offset instruction takes …\nDW_CFA_val_offset_sfThe DW_CFA_val_offset_sf instruction …\nThe value of an entry on the DWARF stack.\nThe piece has no location but its value is known.\nThe type of an entry on the DWARF stack.\nThe <code>.eh_frame_hdr</code> binary search table claims to be …\nThe index of a global.\nThe index of a local in the currently executing function.\nThe index of an item on the operand stack.\nBitwise <code>xor</code> of the top two values on the stack.\nPerform an absolute value operation.\nPerform an addition operation.\nReturn the beginning address of this arange.\nThe size of addresses (in bytes) in this CIE.\nPerform a bitwise and operation.\nGet the result of this <code>Evaluation</code>.\nGet the augmentation data, if any exists.\nThe beginning address of the range.\nIf given, the bit offset of the piece within the location. …\nThe size in bits of a value for this type.\nCreate a <code>DebugAddr</code> section that references the data in <code>self</code>…\nCreate a <code>DebugAranges</code> section that references the data in …\nCreate a <code>LocationLists</code> that references the data in <code>self</code>.\nCreate a <code>RangeLists</code> that references the data in <code>self</code>.\nCreate a <code>DebugStr</code> section that references the data in <code>self</code>.\nCreate a <code>DebugStrOffsets</code> section that references the data …\nCreate a <code>DebugLineStr</code> section that references the data in …\nThis trait cannot be implemented if “read” feature is …\nGet the canonical frame address (CFA) recovery rule for …\nChecked subtraction. Computes <code>self - other</code>.\nGet a reference to this FDE’s CIE.\nParse the <code>CommonInformationEntry</code> at the given offset.\nParse the <code>CommonInformationEntry</code> at the given offset.\nGet the offset of this FDE’s CIE.\nA constant that is factored out of all advance location …\nReturn <code>true</code> if the given address is within this FDE, <code>false</code> …\nReturn <code>true</code> if the given <code>address</code> is within this row’s …\nConvert a <code>Value</code> to the given <code>value_type</code>.\nThe base address for data relative pointers.\nThe data containing a single location description.\nA constant that is factored out of certain offset …\nReturn the offset into the .debug_info section for this …\nReturn the <code>.debug_ranges</code> section.\nReturn the <code>.debug_rnglists</code> section.\nA short description of the error.\nReturn the direct pointer value.\nPerform a division operation.\nReturns the ELF section name for this kind, when found in …\nReturns the ELF section name (if any) for this type when …\nReturns the subrange of the section that is the …\nThe base addresses to use for pointers in the <code>.eh_frame</code> …\nThe base addresses to use for pointers in the <code>.eh_frame_hdr</code>…\nReturns the address of the binary’s <code>.eh_frame</code> section.\nSet the number of bytes remaining to zero.\nReturn the encoding parameters for this CIE.\nReturn the encoding parameters for this set of entries.\nThe first address past the end of the range.\nOne more than the last address that this entry has unwind …\nGet the end PC address where this row’s register rules …\nReturn the endianity of bytes that are read.\nIterate over the <code>CommonInformationEntry</code>s and …\nIterate over the <code>CommonInformationEntry</code>s and …\nReturn the arange entries in this set.\nA constant that gives the number of bytes of the CIE …\nA constant that gives the number of bytes of the header and\nA constant that gives the number of bytes of the header and\nPerform the <code>==</code> relational operation.\nEvaluate a DWARF expression.  This method should only ever …\nReturn the encoding of the addresses for this CIE’s FDEs.\nFind the <code>FrameDescriptionEntry</code> for the given address.\nFind the <code>FrameDescriptionEntry</code> for the given address.\nReturns a parsed FDE for the given address, or …\nParse the <code>FrameDescriptionEntry</code> at the given offset.\nParse the <code>FrameDescriptionEntry</code> at the given offset.\nFind the index of the first occurrence of the given byte. …\nFind the first occurrence of a byte in the slice, and …\nFind <code>id</code> in the index hash table, and return the row index.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConstruct a <code>ValueType</code> from the attributes of a base type …\nConvert an i16 to an offset.\nConvert a u16 to an offset.\nConvert a u32 to an offset.\nConvert a u64 to an offset.\nCreate a <code>Value</code> with the given <code>value_type</code> from a <code>u64</code> value.\nConvert a u8 to an offset.\nPerform the <code>&gt;=</code> relational operation.\nGet the expression from the section.\nReturns the address at the given <code>base</code> and <code>index</code>.\nReturns the <code>.debug_loclists</code> offset at the given <code>base</code> and …\nReturns the <code>.debug_rnglists</code> offset at the given <code>base</code> and …\nLookup a string from the <code>.debug_str</code> section by …\nLookup a string from the <code>.debug_line_str</code> section by …\nReturns the <code>.debug_str</code> offset at the given <code>base</code> and <code>index</code>.\nPerform the <code>&gt;</code> relational operation.\nTrue if this CIE’s FDEs have a LSDA.\nGet the header at the given offset.\nIterate the sets of entries in the <code>.debug_aranges</code> section.\nReturns the section id for this type.\nParse the index header.\nParse the index header.\nThe first address for which this entry has unwind …\nIterate over this CIE’s initial instructions.\nIterate over this FDE’s instructions.\nConvert an <code>UnwindOffset&lt;T&gt;</code> into a <code>T</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the current row with the lifetime of the context.\nConvert an offset to a u64.\nReturn true if the number of bytes remaining is zero.\nReturn true if the number of bytes remaining is zero.\nReturn true if the piece is empty.\nTrue if this CIE’s FDEs are trampolines for signal …\nReturn true if this FDE’s function is a trampoline for a …\nReturn an iterator that can walk the <code>.eh_frame_hdr</code> table.\nPerform the `&lt;= relational operation.\nReturn the number of bytes remaining.\nThe number of bytes of instructions that this entry has …\nReturn the length of this set of entries, including the …\nReturn the length of this arange.\nThe length of the expression.\nTry to load the section using the given loader function.\nWhere this piece is to be found.\nIterate over the <code>LocationListEntry</code>s starting at the given …\nSimilar to <code>locations</code>, but with special handling for .dwo …\n<em>Probably</em> returns a pointer to the FDE for the given …\nReturn the offset corresponding to the given <code>id</code> if it is …\nReturns the <code>Reader</code> for this section.\nCall <code>Reader::lookup_offset_id</code> for each section, and return …\nCall <code>Reader::lookup_offset_id</code> for each section, and return …\nThe address of this FDE’s language-specific data area …\nReturn the encoding of the LSDA address for this CIE’s …\nPerform the `&lt; relational operation.\nPerform a multiplication operation.\nPerform the `!= relational operation.\nPerform a negation operation.\nConstruct a new <code>DebugFrame</code> instance from the data in the …\nConstructs a new <code>EhFrameHdr</code> instance from the data in the …\nConstruct a new <code>EhFrame</code> instance from the data in the …\nConstruct a new <code>UnwindTable</code> for the given …\nConstruct a new <code>EndianSlice</code> with the given slice and …\nCreate a new <code>RelocateReader</code> which applies relocations to …\nConstruct a new <code>DebugAranges</code> instance from the data in the …\nConstruct a new <code>DebugCuIndex</code> instance from the data in the …\nConstruct a new <code>DebugTuIndex</code> instance from the data in the …\nConstruct a new <code>DebugLoc</code> instance from the data in the …\nConstruct a new <code>DebugLocLists</code> instance from the data in …\nConstruct a new <code>LocationLists</code> instance from the data in …\nConstruct a new <code>DebugRanges</code> instance from the data in the …\nConstruct a new <code>DebugRngLists</code> instance from the data in the\nConstruct a new <code>RangeLists</code> instance from the data in the …\nConstruct a new <code>DebugStr</code> instance from the data in the …\nConstruct a new <code>DebugLineStr</code> instance from the data in the …\nConstruct a new call frame unwinding context.\nCreate a new DWARF expression evaluator.\nYield the next entry in the <code>EhHdrTableIter</code>.\nAdvance the iterator to the next entry.\nParse the next call frame instruction.\nAdvance the iterator to the next header.\nAdvance the iterator and return the next arange.\nAdvance the iterator to the next location.\nAdvance the iterator to the next location.\nRead the next operation in an expression.\nAdvance the iterator to the next range.\nAdvance the iterator to the next range.\nAdvance the iterator and return the next arange without …\nEvaluate call frame instructions until the next row of the …\nPerform a bitwise not operation.\nYield the nth entry in the <code>EhHdrTableIter</code>\nGet the offset of this entry from the start of its …\nGet the offset of this entry from the start of its …\nGet the offset of this entry from the start of its …\nReturn the offset of this header within the <code>.debug_aranges</code> …\nThe offset of the expression within the section.\nThe base offset of the unit’s contribution to the …\nReturn the offset of this reader’s data relative to the …\nReturn the offset of the start of the slice relative to …\nReturn the current byte offset of the iterator.\nReturn an identifier for the current reader offset.\nReturn an iterator for the operations in the expression.\nPerform a bitwise or operation.\nParses this <code>EhFrameHdr</code> to a <code>ParsedEhFrameHdr</code>.\nFully parse this FDE.\nParse a single DWARF expression operation.\nRead a <code>Value</code> with the given <code>value_type</code> from a <code>Reader</code>.\nParse the <code>PartialFrameDescriptionEntry</code> at the given offset.\nParse the <code>PartialFrameDescriptionEntry</code> at the given offset.\nReturn the address of the personality routine handler for …\nReturn the address of the FDE’s function’s personality …\nReturn the encoding and address of the personality routine …\nReturn the pointer value, discarding indirectness …\nConvert a <code>Pointer</code> to a section offset.\nTake the given <code>start..end</code> range of the underlying slice …\nReturn the range.\nThe address range that this location is valid for.\nTake the given <code>start..</code> range of the underlying slice and …\nTake the given <code>..end</code> range of the underlying slice and …\nIterate over the <code>Range</code> list entries starting at the given …\nIterate over the raw <code>LocationListEntry</code>s starting at the …\nSimilar to <code>raw_locations</code>, but with special handling for …\nIterate over the <code>RawRngListEntry</code>ies starting at the given …\nRead an address-sized integer, and return it as a <code>u64</code>.\nRead an address-sized integer, and return it as a <code>u64</code>.\nRead a byte and validate it as an address size.\nRead a byte and validate it as an address size.\nRead a f32.\nRead a f32.\nRead a f64.\nRead a f64.\nRead an i16.\nRead an i16.\nRead an i32.\nRead an i32.\nRead an i64.\nRead an i64.\nRead an i8.\nRead an i8.\nRead an initial length field.\nRead an initial length field.\nParse a word-sized section length according to the DWARF …\nParse a word-sized section length according to the DWARF …\nRead a null-terminated slice, and return it (excluding the …\nRead a null-terminated slice, and return it (excluding the …\nParse a word-sized section offset according to the DWARF …\nParse a word-sized section offset according to the DWARF …\nParse a section offset of the given size.\nParse a section offset of the given size.\nRead a signed LEB128 encoded integer.\nRead a signed LEB128 encoded integer.\nRead exactly <code>buf.len()</code> bytes into <code>buf</code>.\nRead a u16.\nRead a u16.\nRead a u32.\nRead a u32.\nRead a u64.\nRead a u64.\nRead a u8.\nRead a u8.\nRead a u8 array.\nRead a u8 array.\nRead an unsigned n-bytes integer u64.\nRead an unsigned n-bytes integer u64.\nRead an unsigned LEB128 encoded integer.\nRead an unsigned LEB128 encoded integer.\nRead an unsigned LEB128 encoded u16.\nRead an unsigned LEB128 encoded u16.\nRead an unsigned LEB128 encoded u32.\nRead an unsigned LEB128 encoded u32.\nParse a word-sized integer according to the DWARF format.\nParse a word-sized integer according to the DWARF format.\nReturns the <code>Reader</code> for this section.\nGet the register recovery rule for the given register …\nIterate over all defined register <code>(number, rule)</code> pairs.\nReinterpret the bits in a <code>Value</code> as the given <code>value_type</code>.\nRelocate an address which was read from the given section …\nRelocate a value which was read from the given section …\nPerform a remainder operation.\nResume the <code>Evaluation</code> with the provided <code>bytes</code>.  This will …\nResume the <code>Evaluation</code> with the provided <code>base_type</code>.  This …\nResume the <code>Evaluation</code> with the provided <code>cfa</code>.  This will …\nResume the <code>Evaluation</code> with the provided <code>entry_value</code>.  This …\nResume the <code>Evaluation</code> with the provided <code>frame_base</code>.  This …\nResume the <code>Evaluation</code> with the provided indexed <code>address</code>.  …\nResume the <code>Evaluation</code> with the provided memory <code>value</code>.  …\nResume the <code>Evaluation</code> with the provided <code>parameter_value</code>.  …\nResume the <code>Evaluation</code> with the provided <code>register</code> value.  …\nResume the <code>Evaluation</code> with the provided relocated <code>address</code>. …\nResume the <code>Evaluation</code> with the provided <code>value</code>.  This will …\nAn unsigned … constant that indicates which column in …\nReturn the table of unwind information for this FDE.\nReturns the amount of args currently on the stack.\nThe address of the section containing the pointer.\nThe section kind.\nReturn the number of sections.\nReturns the corresponding <code>SectionId</code>.\nReturns the ELF section name for this type.\nReturn the section offsets and sizes for the given row …\nSet the size of a target address in bytes.\nSet the size of a target address in bytes.\nReplace the <code>.debug_ranges</code> section.\nSet the <code>.eh_frame</code> section base address.\nSet the <code>.eh_frame_hdr</code> section base address.\nSet the <code>.got</code> section base address.\nSet an initial value to be pushed on the DWARF expression …\nSet the maximum number of iterations to be allowed by the …\nSet the enclosing object’s address, as used by …\nSet the <code>.text</code> section base address.\nSet the vendor extensions to use.\nSet the vendor extensions to use.\nPerform a shift left operation.\nPerform a logical shift right operation.\nPerform an arithmetic shift right operation.\nThe size of the unit’s contribution to the section.\nIf given, the size of the piece in bits.  If <code>None</code>, there …\nDiscard the specified number of bytes.\nSkip a LEB128 encoded integer.\nSkip a LEB128 encoded integer.\nReturn a reference to the raw slice.\nReturn the number of slots.\nSplit a reader in two.\nSplit the slice in two at the given index, resulting in …\nGet the starting PC address that this row applies to.\nPerform a subtraction operation.\nRetrieves the CFI binary search table, if there is one.\nThe base address for text relative pointers. This is …\nConverts the slice to a string using <code>str::from_utf8</code>.\nConvert a <code>Value</code> to a <code>u64</code>.\nSet the number of bytes remaining to the specified length.\nReturn the number of units.\nFind the frame unwind information for the given address.\nFind the frame unwind information for the given address.\nReturns the frame unwind information for the given address,\nFind the frame unwind information for the given address.\nGet the result if this is an evaluation for a value.\nReturn the <code>ValueType</code> corresponding to this <code>Value</code>.\nA version number (see Section 7.23). This number is …\nReturn the version.\nWrapping (modular) addition. Computes <code>self + other</code>.\nReturns the XCOFF section name (if any) for this type when …\nPerform a bitwise exclusive-or operation.\nThe target address.\nThe delta to be added to the current address.\nThe number of the register whose rule is being changed.\nThe location of the DWARF expression.\nThe location of the DWARF expression.\nThe location of the DWARF expression.\nThe factored offset.\nThe factored offset.\nThe factored offset.\nThe factored offset.\nThe factored offset.\nThe factored offset.\nThe non-factored offset.\nThe non-factored offset.\nThe target register’s number.\nThe target register’s number.\nThe target register’s number.\nThe target register’s number.\nThe target register’s number.\nThe target register’s number.\nThe target register’s number.\nThe target register’s number.\nThe target register’s number.\nThe target register’s number.\nThe target register’s number.\nThe register to be reset.\nThe size of the arguments which have been pushed onto the …\nThe number of the register where the other register’s …\nThe offset from the register’s base value.\nThe register containing the base value.\nThe address of the value required.\nThe DIE of the base type or 0 to indicate the generic type\nThe DIE of the base type or 0 to indicate the generic type\nThe index of the address in the <code>.debug_addr</code> section, …\nThe register number.\nWhether the address also needs to be relocated.\nThe size of the value required. This is guaranteed to be …\nIf not <code>None</code>, a target-specific address space value.\nThe address.\nThe byte offset into the value that the implicit pointer …\nThe register number.\nThe value.\nThe value.\nThe <code>.debug_info</code> offset of the value that this is an …\nThe offset to add.\nThe DIE of the base type or 0 to indicate the generic type\nThe DIE of the base type or 0 to indicate the generic type\nThe DIE of the base type.\nThe DIE of the base type.\nThe DIE of the base type.\nThe bit offset of this piece.  If <code>None</code>, then this piece …\nThe byte offset into the value that the implicit pointer …\nThe implicit value to use.\nThe expression to be evaluated.\nThe index, from the top of the stack, of the item to copy.\nThe index of the address in <code>.debug_addr</code>.\nThe index of the address in <code>.debug_addr</code>.\nThe index of the local.\nThe index of the global.\nThe index of the stack item. 0 is the bottom of the …\nThe offset to add.\nThe offset to add.\nThe DIE to use.\nThe DIE to use.\nThe register number.\nThe register number.\nThe size of the data to dereference.\nThe size of this piece in bits.\nTrue if the dereference operation takes an address space …\nThe relative offset to the target bytecode.\nThe relative offset to the target bytecode.\nThe value to add.\nThe value to push.\nThe value to push.\nThe <code>.debug_info</code> offset of the value that this is an …\nThe value bytes.\nbase address\nbase address\nStart of range. May be an address or an offset.\nstart of range\nstart of range\nstart of range\nstart of range\nstart of range\nexpression\nexpression\nexpression\nexpression\nexpression\nexpression\nexpression\nEnd of range. May be an address or an offset.\nend of range\nend of range\nend of range\nlength of range\nlength of range\nbase address\nbase address\nStart of range. May be an address or an offset.\nstart of range\nstart of range\nstart of range\nstart of range\nstart of range\nEnd of range. May be an address or an offset.\nend of range\nend of range\nend of range\nlength of range\nlength of range")